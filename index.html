<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SecureCheck - Protocol Checklist</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/boxicons@2.1.4/css/boxicons.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Manrope:wght@300;400;500;600;700&display=swap');
        
        :root {
            --primary: #8b5cf6;
            --primary-dark: #7c3aed;
            --primary-light: #a78bfa;
            --primary-alpha: rgba(139, 92, 246, 0.2);
            --secondary: #10b981;
            --secondary-alpha: rgba(16, 185, 129, 0.2);
            --dark: #0f172a;
            --darker: #020617;
            --light: #f8fafc;
            --neutral: #64748b;
            --glass-light: rgba(255, 255, 255, 0.05);
            --glass-dark: rgba(0, 0, 0, 0.2);
            --card-bg: rgba(15, 23, 42, 0.7);
            --sidebar-bg: rgba(2, 6, 23, 0.85);
            --glow: 0 0 15px rgba(139, 92, 246, 0.6);
            --transition-smooth: 0.5s cubic-bezier(0.33, 1, 0.68, 1);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Manrope', system-ui, -apple-system, sans-serif;
        }

        body {
            background: var(--darker);
            color: var(--light);
            min-height: 100vh;
            overflow-x: hidden;
            background-image: 
                radial-gradient(circle at 10% 20%, rgba(139, 92, 246, 0.05) 0%, transparent 20%),
                radial-gradient(circle at 90% 80%, rgba(16, 185, 129, 0.05) 0%, transparent 20%),
                radial-gradient(circle at 50% 50%, rgba(15, 23, 42, 0.8) 0%, var(--darker) 100%);
        }


        /* Glass Morphism Base Styles */
        .glass {
            background: rgba(15, 23, 42, 0.6);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.05);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }

        .glass-dark {
            background: rgba(2, 6, 23, 0.8);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.03);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .glass-card {
            background: rgba(15, 23, 42, 0.6);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.05);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            border-radius: 16px;
            transition: all var(--transition-smooth);
        }

        .glass-card:hover {
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.3), 0 0 20px rgba(139, 92, 246, 0.2);
            transform: translateY(-3px);
        }

        .glass-inset {
            background: rgba(2, 6, 23, 0.5);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 16px;
            box-shadow: 
                inset 2px 2px 5px rgba(0, 0, 0, 0.5), 
                inset -2px -2px 5px rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.03);
        }

        /* Animated Background Effect */
        .animated-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            overflow: hidden;
        }

        .floating-particle {
            position: absolute;
            background: var(--primary-alpha);
            border-radius: 50%;
            filter: blur(8px);
            opacity: 0;
            animation: float 20s infinite linear;
        }

        @keyframes float {
            0% {
                opacity: 0;
                transform: translateY(0) translateX(0) rotate(0deg);
            }
            10% {
                opacity: 0.5;
            }
            90% {
                opacity: 0.5;
            }
            100% {
                opacity: 0;
                transform: translateY(calc(-100vh - 100px)) translateX(calc(100vw * var(--x-travel))) rotate(360deg);
            }
        }

        .sidebar {
            background: var(--sidebar-bg);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            height: 100vh;
            position: fixed;
            padding: 2rem 1.5rem;
            width: 300px;
            z-index: 50;
            transition: transform 0.6s cubic-bezier(0.22, 1, 0.36, 1);
            border-right: 1px solid rgba(255, 255, 255, 0.03);
            display: flex;
            flex-direction: column;
            overflow-y: hidden;
        }

        .content-area {
            margin-left: 300px;
            padding: 2rem;
            min-height: 100vh;
            transition: margin-left 0.6s cubic-bezier(0.22, 1, 0.36, 1);
        }

        @media (max-width: 1024px) {
            .sidebar {
                transform: translateX(-100%);
            }
            .sidebar.open {
                transform: translateX(0);
            }
            .content-area {
                margin-left: 0;
            }
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            .content-area {
                padding: 1.5rem 1rem;
            }
            
            header h1 {
                font-size: 1.75rem !important;
            }
            
            .card-header {
                flex-direction: column !important;
                align-items: flex-start !important;
            }
            
            .card-header > div:last-child {
                width: 100%;
                justify-content: space-between;
                margin-top: 1rem;
            }
            
            .progress-container {
                width: 100% !important;
            }
        }

        .protocol-card {
            transition: all var(--transition-smooth);
            transform-style: preserve-3d;
            perspective: 1000px;
            overflow: hidden;
            transform: translateZ(0); 
            will-change: transform, box-shadow, max-height; 
            backface-visibility: hidden;
        }

        .protocol-card.expanded {
            transform: translateZ(10px);
        }

        .protocol-card:hover {
            box-shadow: 0 0 25px rgba(0, 0, 0, 0.3), 0 0 15px rgba(139, 92, 246, 0.15);
        }

        .card-header {
            cursor: pointer;
            transition: all 0.4s ease;
        }

        .card-header:hover .category-badge::after {
            animation: shine 2s infinite;
        }

        .card-content {
            max-height: 0;
            overflow: hidden;
            padding: 0;
            transition: all 0.6s cubic-bezier(0.16, 1, 0.3, 1);
            opacity: 0;
            visibility: hidden;
            transform: translateY(10px);
            will-change: max-height, opacity, transform, padding;
            transform-origin: top;
        }

        .protocol-card.expanded .card-content {
            max-height: 2000px;
            opacity: 1;
            visibility: visible;
            padding: 0 20px 20px 20px;
            transform: translateY(0);
        }

        /* Elegant Toggle Switch */
        .toggle-container {
            position: relative;
            width: 50px;
            height: 26px;
            flex-shrink: 0;
            min-width: 50px;
        }

        .toggle-input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(15, 23, 42, 0.7);
            transition: all 0.4s cubic-bezier(0.22, 1, 0.36, 1);
            border-radius: 34px;
            box-shadow: 
                inset 2px 2px 4px var(--glass-dark), 
                inset -2px -2px 4px var(--glass-light);
            overflow: hidden;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 4px;
            bottom: 4px;
            background: var(--light);
            transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            z-index: 2;
        }

        .toggle-slider::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                var(--primary-dark) 0%, 
                var(--primary) 100%);
            transition: all 0.4s cubic-bezier(0.22, 1, 0.36, 1);
            opacity: 0;
        }

        .toggle-input:checked + .toggle-slider::after {
            left: 0;
            opacity: 1;
        }

        .toggle-input:checked + .toggle-slider:before {
            transform: translateX(24px);
            background: white;
        }

        .toggle-input:checked + .toggle-slider {
            box-shadow: 0 0 8px var(--primary-alpha);
        }

        /* Animated Progress bar */
        .progress-container {
            width: 100%;
            height: 12px;
            background: rgba(15, 23, 42, 0.5);
            border-radius: 10px;
            box-shadow: 
                inset 2px 2px 4px var(--glass-dark), 
                inset -2px -2px 4px var(--glass-light);
            margin: 1rem 0;
            overflow: hidden;
            position: relative;
        }

        .progress-container::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, 
                transparent 0%, 
                rgba(255, 255, 255, 0.1) 50%, 
                transparent 100%);
            opacity: 0.5;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-dark), var(--primary), var(--primary-light));
            border-radius: 10px;
            transition: width 1s cubic-bezier(0.22, 1, 0.36, 1);
            position: relative;
            overflow: hidden;
        }

        .progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent 0%, 
                rgba(255, 255, 255, 0.2) 50%, 
                transparent 100%);
            animation: progressShine 2s infinite;
        }

        @keyframes progressShine {
            to { left: 100%; }
        }

        /* Glowing Category badges */
        .category-badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: 600;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            box-shadow: 0 2px 10px rgba(139, 92, 246, 0.3);
            position: relative;
            overflow: hidden;
        }

        .category-badge::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                rgba(255, 255, 255, 0) 0%, 
                rgba(255, 255, 255, 0.3) 50%, 
                rgba(255, 255, 255, 0) 100%);
            transform: skewX(-25deg);
            transition: all 0.8s ease;
        }

        @keyframes shine {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        /* Category filters with elegant motion */
        .category-filters {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
            margin-bottom: 1rem;
        }

        .category-filter {
            padding: 0.4rem 1rem;
            border-radius: 9999px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.22, 1, 0.36, 1);
            background: rgba(15, 23, 42, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.05);
            position: relative;
            overflow: hidden;
            font-weight: 500;
            will-change: transform;
            font-size: 0.85rem;
        }

        .category-filter:hover {
            background: rgba(15, 23, 42, 0.5);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .category-filter.active {
            background: var(--primary);
            box-shadow: 0 0 20px rgba(139, 92, 246, 0.3);
            transform: translateY(-2px);
        }

        .category-filter.active::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 200%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent 0%, 
                rgba(255, 255, 255, 0.2) 50%, 
                transparent 100%);
            animation: shine 3s infinite;
        }

        /* Animation effects */
        .fade-in {
            animation: fadeIn 0.8s cubic-bezier(0.22, 1, 0.36, 1) forwards;
            opacity: 0;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .slide-in-right {
            animation: slideInRight 0.8s cubic-bezier(0.22, 1, 0.36, 1) forwards;
        }

        @keyframes slideInRight {
            from { transform: translateX(50px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(15, 23, 42, 0.2);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--primary-dark);
            border-radius: 10px;
            transition: all 0.3s ease;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary);
            box-shadow: 0 0 10px var(--primary);
        }

        /* Section animations */
        .section-animate {
            opacity: 0;
            transform: translateY(30px);
            transition: opacity 0.8s cubic-bezier(0.22, 1, 0.36, 1), transform 0.8s cubic-bezier(0.22, 1, 0.36, 1);
        }

        .section-animate.visible {
            opacity: 1;
            transform: translateY(0);
        }

        /* List item animations */
        .list-item-animate {
            opacity: 0;
            transform: translateX(20px);
            transition: all 0.5s cubic-bezier(0.22, 1, 0.36, 1);
        }

        .list-item-visible {
            opacity: 1;
            transform: translateX(0);
        }

        /* Elegant Search bar */
        .search-container {
            position: relative;
            margin-bottom: 1.25rem;
        }

        .search-input {
            width: 100%;
            padding: 0.75rem 1rem 0.75rem 3rem;
            border-radius: 12px;
            background: rgba(15, 23, 42, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.05);
            color: var(--light);
            transition: all 0.4s cubic-bezier(0.22, 1, 0.36, 1);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
        }

        .search-input:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--primary-alpha), 0 0 15px rgba(139, 92, 246, 0.3);
            background: rgba(15, 23, 42, 0.5);
            border-color: rgba(139, 92, 246, 0.3);
        }

        .search-icon {
            position: absolute;
            left: 1rem;
            top: 50%;
            transform: translateY(-50%);
            color: var(--neutral);
            transition: color 0.3s ease;
        }

        .search-input:focus + .search-icon {
            color: var(--primary);
        }

        /* Style for protocol nav area */
        .nav-links {
            flex: 1;
            overflow-y: auto;
            padding-right: 5px;
            margin-bottom: 1rem;
            max-height: calc(100vh - 180px);
        }

        /* Protocol navigation item styling */
        .protocol-nav-item {
            margin-bottom: 0.6rem;
            border-radius: 12px;
            transition: all 0.4s cubic-bezier(0.22, 1, 0.36, 1);
            will-change: transform, box-shadow, background;
        }

        .protocol-nav-item:hover {
            transform: translateX(5px);
            background: rgba(15, 23, 42, 0.8) !important;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1), 0 0 5px rgba(139, 92, 246, 0.2);
        }

        .protocol-nav-item.hidden {
            display: none;
        }

        /* Card category indicators */
        .category-indicator {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 4px;
            border-top-left-radius: 16px;
            border-bottom-left-radius: 16px;
        }

        /* Expand button animation */
        .expand-btn {
            position: relative;
            overflow: hidden;
            transition: all 0.4s cubic-bezier(0.22, 1, 0.36, 1);
        }

        .expand-btn:hover {
            box-shadow: 0 0 15px rgba(139, 92, 246, 0.3);
            transform: translateY(-2px);
        }

        .expand-btn::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle, rgba(139, 92, 246, 0.2) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .expand-btn:hover::after {
            opacity: 1;
        }

        .expand-btn i {
            transition: transform 0.5s cubic-bezier(0.22, 1, 0.36, 1);
        }

        /* No results message */
        .no-results {
            text-align: center;
            padding: 3rem;
            background: rgba(15, 23, 42, 0.5);
            border-radius: 1rem;
            margin: 2rem 0;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.03);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            transition: all 0.5s cubic-bezier(0.22, 1, 0.36, 1);
        }

        .no-results:hover {
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.2), 0 0 20px rgba(139, 92, 246, 0.1);
            transform: translateY(-5px);
        }

        /* Logo animation */
        .logo {
            position: relative;
            display: inline-block;
        }

        .logo::after {
            content: '';
            position: absolute;
            left: 0;
            right: 0;
            bottom: -3px;
            height: 2px;
            background: linear-gradient(90deg, var(--primary-dark), var(--primary), var(--primary-dark));
            transform: scaleX(0);
            transform-origin: left;
            transition: transform 0.6s cubic-bezier(0.22, 1, 0.36, 1);
        }

        .logo:hover::after {
            transform: scaleX(1);
        }

        /* Mobile menu animation */
        .menu-toggle {
            transition: all 0.4s cubic-bezier(0.22, 1, 0.36, 1);
            z-index: 60;
        }

        .menu-toggle:hover {
            transform: rotate(90deg);
            box-shadow: 0 0 15px rgba(139, 92, 246, 0.3);
        }

        /* Card content animation */
        .content-section {
            transition: all 0.5s cubic-bezier(0.22, 1, 0.36, 1);
            transform: translateY(20px);
            opacity: 0;
        }

        .protocol-card.expanded .content-section {
            transform: translateY(0);
            opacity: 1;
        }
        
        /* Completion percentage display */
        .completion-percentage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.75rem;
            font-weight: 600;
            color: white;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .progress-container:hover .completion-percentage {
            opacity: 1;
        }
        
        /* Checkmark animation */
        .checkmark-animate {
            transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        .toggle-input:checked ~ .checkmark-animate {
            transform: scale(1.1) rotate(5deg);
        }
        
        /* Hover states for list items */
        li.list-item-animate {
            transition: all 0.3s ease;
            border-radius: 8px;
            padding: 0.5rem;
        }
        
        li.list-item-animate:hover {
            background: rgba(255, 255, 255, 0.05);
            transform: translateX(5px);
        }

        /* Category section adjustments */
        .category-section h2 {
            margin-bottom: 0.75rem;
            font-size: 1rem;
        }

        /* Protocol section adjustments */
        .protocol-section h2 {
            margin-bottom: 0.75rem;
            font-size: 1.1rem;
        }

        /* Pagination styles */
        .pagination-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 2rem;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .pagination-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(15, 23, 42, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.05);
            color: var(--light);
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .pagination-btn:hover:not(:disabled) {
            background: rgba(15, 23, 42, 0.5);
            box-shadow: 0 0 15px rgba(139, 92, 246, 0.2);
            transform: translateY(-2px);
        }

        .pagination-btn.active {
            background: var(--primary);
            color: white;
            font-weight: 600;
            box-shadow: 0 0 20px rgba(139, 92, 246, 0.3);
        }

        .pagination-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .pagination-ellipsis {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            color: var(--neutral);
        }

        /* Port badge styles */
        .port-badge {
            font-family: 'Courier New', monospace;
            background: rgba(15, 23, 42, 0.5);
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-size: 0.8rem;
            margin-left: 0.5rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Virtual list styles */
        .virtual-list-container {
            position: relative;
        }

        .virtual-list-spacer {
            position: relative;
            width: 100%;
            visibility: hidden;
        }

        /* Loading indicator */
        .loading-indicator {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 2rem;
            font-weight: 500;
            color: var(--neutral);
        }

        .loading-spinner {
            width: 24px;
            height: 24px;
            border: 3px solid rgba(139, 92, 246, 0.2);
            border-radius: 50%;
            border-top-color: var(--primary);
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Mobile responsiveness improvements */
        @media (max-width: 640px) {
            .category-filter {
                padding: 0.3rem 0.8rem;
                font-size: 0.75rem;
            }
            
            .category-badge {
                font-size: 0.65rem;
                padding: 0.2rem 0.6rem;
            }
            
            .progress-container {
                height: 10px;
            }
            
            .card-header {
                padding: 1rem !important;
            }
            
            .card-header h2 {
                font-size: 1.5rem !important;
            }
            
            .protocol-card .grid {
                display: block !important;
            }
            
            .glass-inset {
                margin-bottom: 1rem;
            }
            
            .toggle-container {
                min-width: 40px;
                width: 40px;
                height: 22px;
            }
            
            .toggle-slider:before {
                height: 14px;
                width: 14px;
            }
            
            .toggle-input:checked + .toggle-slider:before {
                transform: translateX(18px);
            }
        }
        
        /* Protocol card mobile optimizations */
        @media (max-width: 768px) {
            .card-content {
                transition-duration: 0.4s;
            }
            
            .protocol-card.expanded .card-content {
                padding: 0 15px 15px 15px;
            }
            
            .content-section {
                transition-delay: 0.05s !important;
            }
            
            .list-item-animate {
                transition-delay: 0ms !important;
                margin-bottom: 0.5rem;
            }
        }
        
        /* Prevent content jumping during animation */
        .card-container {
            min-height: 0;
            transition: min-height 0.5s ease;
        }
        
        /* Improved touch targets for mobile */
        @media (max-width: 640px) {
            .protocol-nav-item {
                padding: 0.75rem !important;
            }
            
            li.list-item-animate {
                padding: 0.75rem 0.5rem;
                margin-bottom: 0.75rem;
            }
            
            .pagination-btn {
                width: 36px;
                height: 36px;
            }
            
            .expand-btn {
                padding: 0.75rem !important;
            }
        }
    </style>
</head>
<body>
    <!-- Background Animation Elements -->
    <div class="animated-bg" id="animatedBg"></div>

    <!-- Mobile menu toggle -->
    <div class="fixed top-4 left-4 z-50 lg:hidden">
        <button id="menuToggle" class="menu-toggle p-2 glass-dark rounded-full text-white focus:outline-none">
            <i class="bx bx-menu text-2xl"></i>
        </button>
    </div>

    <!-- Sidebar -->
    <aside class="sidebar glass-dark" id="sidebar">
        <div class="flex flex-col mb-8">
    <div class="flex items-center justify-between">
        <h1 class="text-2xl font-bold tracking-tight logo">
            <span class="text-primary">Secure</span>Check
        </h1>
        <button id="mobileClose" class="lg:hidden p-1 rounded-full hover:bg-gray-700 focus:outline-none">
            <i class="bx bx-x text-2xl"></i>
        </button>
    </div>
    <div class="flex items-center mt-2">
        <p class="text-xs text-gray-400 tracking-wide relative group">
            <span class="text-primary">◈</span> Created by <span class="underline cursor-pointer text-gray-300 hover:text-primary transition-colors duration-300">Aditya Singh</span>
            <span class="absolute bottom-full left-0 mb-2 w-48 p-2 bg-gray-800 rounded-md shadow-lg text-xs opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none">
                https://www.youtube.com/watch?v=dQw4w9WgXcQ<br>© 2025 All Rights Reserved
            </span>
        </p>
    </div>
</div>
        
        <div class="search-container">
            <input type="text" id="search" class="search-input" placeholder="Search protocols or ports...">
            <i class="bx bx-search search-icon"></i>
        </div>
        
        <div class="category-section">
            <h2 class="text-sm font-semibold mb-1 text-neutral-400">Categories</h2>
            <div class="category-filters mb-4" id="categoryFilters">
                <button class="category-filter active" data-category="all">All</button>
                <!-- Categories will be populated dynamically -->
            </div>
        </div>
        
        <div class="protocol-section">
            <h2 class="text-lg font-semibold mb-2 text-neutral-300">Protocols</h2>
            <div class="nav-links space-y-2" id="protocolNav">
                <!-- Protocol navigation will be populated dynamically -->
            </div>
        </div>
    </aside>

    <!-- Main content -->
    <main class="content-area" id="mainContent">
        <header class="mb-6 md:mb-10 fade-in" style="animation-delay: 0.1s;">
            <h1 class="text-3xl md:text-4xl font-bold mb-2">Protocol Security Checklist</h1>
            <p class="text-gray-400">Track vulnerabilities, testing procedures, and security tools for network protocols.</p>
        </header>
        
        <div class="grid grid-cols-1 gap-6" id="protocolCards">
            <!-- Protocol cards will be populated dynamically -->
        </div>

        <!-- Pagination -->
        <div class="pagination-container" id="paginationContainer">
            <!-- Pagination will be generated dynamically -->
        </div>
    </main>

    <script>
        // Sample data for demonstration
        const protocolData = [
            {
                id: 'ftp',
                name: 'FTP',
                port: '21',
                category: 'file',
                description: 'File Transfer Protocol used for transferring files between client and server.',
                vulnerabilities: [
                    'Anonymous access',
                    'Brute force attacks',
                    'Clear-text credentials',
                    'FTP bounce attacks',
                    'Directory traversal',
                    'Outdated FTP servers'
                ],
                testing: [
                    'Check for anonymous login: `ftp target.com` (user: anonymous, pass: anonymous)',
                    'Attempt brute force: `hydra -L users.txt -P pass.txt ftp://target.com`',
                    'Check for FTP bounce attack: `nmap -b anonymous:anonymous@target.com otherserver.com`',
                    'Look for sensitive data in FTP directories',
                    'Test for directory traversal using "../" sequences'
                ],
                tools: [
                    'Nmap FTP scripts',
                    'Hydra',
                    'Medusa',
                    'Metasploit FTP auxiliary modules',
                    'FileZilla (for manual testing)'
                ]
            },
            {
                id: 'ssh',
                name: 'SSH',
                port: '22',
                category: 'remote',
                description: 'Secure Shell protocol used for secure remote login and other secure network services.',
                vulnerabilities: [
                    'Weak passwords',
                    'Outdated SSH versions (v1, older v2)',
                    'Misconfigured permissions',
                    'Authentication bypass CVEs',
                    'SSH user enumeration timing attacks',
                    'Default or backdoor credentials'
                ],
                testing: [
                    'Enumerate version: `nmap -sV -p 22 target.com`',
                    'Check for weak ciphers: `nmap --script ssh2-enum-algos target.com`',
                    'Attempt brute force: `hydra -L users.txt -P pass.txt ssh://target.com`',
                    'Test for user enumeration: `metasploit auxiliary/scanner/ssh/ssh_enumusers`',
                    'Check for authorized_keys file permissions',
                    'Look for CVEs for specific SSH versions'
                ],
                tools: [
                    'Nmap SSH scripts',
                    'Hydra',
                    'ssh_scan',
                    'Metasploit SSH modules',
                    'sslyze'
                ]
            },
            {
                id: 'telnet',
                name: 'Telnet',
                port: '23',
                category: 'remote',
                description: 'Legacy unencrypted protocol for remote terminal connections.',
                vulnerabilities: [
                    'Clear-text transmission',
                    'No encryption by default',
                    'Susceptible to MITM attacks',
                    'Brute force vulnerabilities',
                    'Default credentials'
                ],
                testing: [
                    'Connect manually: `telnet target.com 23`',
                    'Sniff credentials: `tcpdump -i eth0 -nn port 23 -w telnet.pcap`',
                    'Check for authentication bypass',
                    'Attempt brute force: `hydra -L users.txt -P pass.txt telnet://target.com`',
                    'Look for information leakage in banners'
                ],
                tools: [
                    'Nmap Telnet scripts',
                    'Wireshark',
                    'tcpdump',
                    'Hydra',
                    'Metasploit Telnet modules'
                ]
            },
            {
                id: 'smtp',
                name: 'SMTP',
                port: '25,465,587',
                category: 'messaging',
                description: 'Simple Mail Transfer Protocol used for sending email messages.',
                vulnerabilities: [
                    'Open relay',
                    'SMTP user enumeration',
                    'Outdated SMTP servers',
                    'Cleartext authentication',
                    'SSL/TLS vulnerabilities',
                    'SMTP command injection'
                ],
                testing: [
                    'Test for open relay: `telnet target.com 25`',
                    'User enumeration: `VRFY admin` or `EXPN admin`',
                    'Attempt to enumerate users with tools',
                    'Check for cleartext auth: `nmap --script smtp-commands target.com`',
                    'Test for SMTP command injection'
                ],
                tools: [
                    'Nmap SMTP scripts',
                    'smtp-user-enum',
                    'Metasploit SMTP modules',
                    'swaks',
                    'SMTPTester'
                ]
            },
            {
                id: 'dns',
                name: 'DNS',
                port: '53',
                category: 'other',
                description: 'Domain Name System protocol for resolving domain names to IP addresses.',
                vulnerabilities: [
                    'Zone transfer',
                    'DNS cache poisoning',
                    'DNSSEC issues',
                    'Dynamic DNS vulnerabilities',
                    'Information leakage',
                    'DNS amplification attacks'
                ],
                testing: [
                    'Zone transfer attempt: `dig axfr @target.com domain.com`',
                    'DNS enumeration: `dnsrecon -d domain.com`',
                    'Subdomain discovery: `dnsenum domain.com`',
                    'Check for DNSSEC misconfiguration',
                    'Test for cache poisoning vulnerabilities'
                ],
                tools: [
                    'dig',
                    'nslookup',
                    'dnsenum',
                    'dnsrecon',
                    'fierce',
                    'Sublist3r'
                ]
            },
            {
                id: 'tftp',
                name: 'TFTP',
                port: '69',
                category: 'file',
                description: 'Trivial File Transfer Protocol, a simplified version of FTP with no authentication.',
                vulnerabilities: [
                    'No authentication',
                    'Directory traversal',
                    'File exfiltration',
                    'Sensitive file upload/download',
                    'Outdated TFTP servers'
                ],
                testing: [
                    'Connect and download files: `tftp target.com`',
                    'Try get/put commands on sensitive files',
                    'Attempt directory traversal: `get ../../../etc/passwd`',
                    'Scan for vulnerable TFTP servers: `nmap -sU -p 69 --script tftp-enum target.com`'
                ],
                tools: [
                    'tftp client',
                    'Nmap TFTP scripts',
                    'Metasploit TFTP modules',
                    'tftp-bruteforce',
                    'TFTP utilities'
                ]
            },
            {
                id: 'http',
                name: 'HTTP/HTTPS',
                port: '80,443',
                category: 'web',
                description: 'Hypertext Transfer Protocol and its secure variant for web content delivery.',
                vulnerabilities: [
                    'Injection flaws (SQL, XSS, CSRF)',
                    'Authentication vulnerabilities',
                    'Security misconfigurations',
                    'Sensitive data exposure',
                    'Broken access control',
                    'Outdated components with CVEs',
                    'SSL/TLS issues'
                ],
                testing: [
                    'Web application scanning: `nikto -h target.com`',
                    'Directory brute-force: `gobuster dir -u target.com -w wordlist.txt`',
                    'Check for SSL issues: `sslscan target.com`',
                    'Test for SQL injection: `sqlmap -u "https://target.com/page.php?id=1"`',
                    'Look for sensitive data in source code',
                    'Check for default credentials',
                    'Analyze HTTP headers and cookies'
                ],
                tools: [
                    'Burp Suite',
                    'OWASP ZAP',
                    'Nikto',
                    'Gobuster/Dirbuster',
                    'sqlmap',
                    'sslscan',
                    'Wfuzz'
                ]
            }
        ];

        // Global application state
        const appState = {
            currentFilter: 'all',
            searchTerm: '',
            checkedItems: {},
            currentPage: 1,
            itemsPerPage: 5,
            debug: false,
            expandedCards: new Set(), // Track expanded cards for animation purposes
            isMobile: window.innerWidth < 768 // Track device type
        };

        // Debug logging function
        function debug(message) {
            if (!appState.debug) return;
            console.log(`[DEBUG] ${message}`);
        }

        // Initialize the app when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            debug('Application initializing...');
            
            // Check if we're on mobile
            appState.isMobile = window.innerWidth < 768;
            if (appState.isMobile) {
                appState.itemsPerPage = 3; // Show fewer items per page on mobile
            }
            
            // Create background particles
            createBackgroundParticles();
            
            // Load checked items from localStorage
            const savedCheckedItems = localStorage.getItem('checkedItems');
            if (savedCheckedItems) {
                appState.checkedItems = JSON.parse(savedCheckedItems);
                debug(`Loaded ${Object.keys(appState.checkedItems).length} checked items from storage`);
            }

            // Initialize UI components
            initializeSidebar();
            renderProtocolCards();
            setupEventListeners();
            initializeAnimations();
            
            debug('Application initialized successfully');
        });
        
        // Create animated background particles
        function createBackgroundParticles() {
            const container = document.getElementById('animatedBg');
            // Fewer particles on mobile for better performance
            const particleCount = appState.isMobile ? 8 : 15;
            
            for (let i = 0; i < particleCount; i++) {
                const size = Math.random() * 150 + 50; // 50-200px
                const particle = document.createElement('div');
                particle.className = 'floating-particle';
                particle.style.width = `${size}px`;
                particle.style.height = `${size}px`;
                particle.style.left = `${Math.random() * 100}vw`;
                particle.style.bottom = `-${size}px`;
                particle.style.animationDuration = `${Math.random() * 20 + 15}s`; // 15-35s
                particle.style.animationDelay = `${Math.random() * 10}s`;
                particle.style.setProperty('--x-travel', Math.random() * 0.4 - 0.2); // -0.2 to 0.2
                
                // Randomly choose between primary and secondary colors
                if (Math.random() > 0.5) {
                    particle.style.background = 'var(--primary-alpha)';
                } else {
                    particle.style.background = 'var(--secondary-alpha)';
                }
                
                container.appendChild(particle);
            }
        }
        
        function getPortDisplay(port) {
            // Convert port to string if it's a number
            const portStr = String(port);
            
            // Now we can safely use string methods
            if (portStr.includes(',') || portStr.includes('-')) {
                return `Ports ${portStr}`;
            } else {
                return `Port ${portStr}`;
            }
        }
        
        // Initialize the sidebar with protocol navigation and category filters
        function initializeSidebar() {
            debug('Initializing sidebar...');
            
            const protocolNav = document.getElementById('protocolNav');
            const categoryFilters = document.getElementById('categoryFilters');
            protocolNav.innerHTML = ''; // Clear existing content
            
            // Extract unique categories
            const categories = [...new Set(protocolData.map(protocol => protocol.category))];
            debug(`Found ${categories.length} unique categories: ${categories.join(', ')}`);
            
            // Clear existing category filters except "All"
            const allCategoryBtn = categoryFilters.querySelector('[data-category="all"]');
            categoryFilters.innerHTML = '';
            categoryFilters.appendChild(allCategoryBtn);
            
            // Create category filters
            categories.forEach(category => {
                const categoryBtn = document.createElement('button');
                categoryBtn.className = 'category-filter';
                categoryBtn.setAttribute('data-category', category);
                categoryBtn.textContent = category.charAt(0).toUpperCase() + category.slice(1);
                categoryFilters.appendChild(categoryBtn);
            });
            
            // Create protocol navigation links
            protocolData.forEach((protocol, index) => {
                const navItem = document.createElement('div');
                navItem.className = 'glass-card p-3 cursor-pointer transition-all duration-300 protocol-nav-item';
                navItem.setAttribute('data-protocol-id', protocol.id);
                navItem.setAttribute('data-category', protocol.category);
                navItem.style.animationDelay = `${index * 0.1}s`;
                
                // Format port display to handle multiple ports
                let portDisplay = getPortDisplay(protocol.port);
                
                navItem.innerHTML = `
                    <div class="flex items-center justify-between">
                        <div class="flex items-center">
                            <i class="bx bx-chevron-right mr-2 text-primary"></i>
                            <span>${protocol.name}</span>
                        </div>
                        <span class="text-xs px-2 py-1 rounded-full bg-gray-800">${portDisplay}</span>
                    </div>
                `;
                protocolNav.appendChild(navItem);
                
                // Add staggered fade-in animation
                setTimeout(() => {
                    navItem.classList.add('fade-in');
                }, 50 + (index * 50));
            });
            
            debug('Sidebar initialized successfully');
        }

        // Get filtered and sorted protocols
        function getFilteredProtocols() {
            // Filter protocols based on current criteria
            const filteredProtocols = protocolData.filter(protocol => {
                const matchesCategory = appState.currentFilter === 'all' || protocol.category === appState.currentFilter;
                
                // Enhanced search functionality for ports
                const matchesSearch = appState.searchTerm === '' || 
                    protocol.name.toLowerCase().includes(appState.searchTerm.toLowerCase()) ||
                    protocol.description.toLowerCase().includes(appState.searchTerm.toLowerCase()) ||
                    matchesPort(protocol.port, appState.searchTerm);
                
                return matchesCategory && matchesSearch;
            });
            
            return [...filteredProtocols];
        }
        
        // Check if a port matches the search term
        function matchesPort(protocolPort, searchTerm) {
            // If protocol port contains commas, it's already multiple ports
            if (protocolPort.toString().includes(',')) {
                const portList = protocolPort.toString().split(',').map(p => p.trim());
                return portList.some(port => searchTerm.includes(port));
            }
            
            // Handle port ranges (e.g., 80-100)
            if (protocolPort.toString().includes('-')) {
                const [minPort, maxPort] = protocolPort.toString().split('-').map(p => parseInt(p.trim()));
                if (searchTerm.includes('-')) {
                    const [minSearch, maxSearch] = searchTerm.split('-').map(p => parseInt(p.trim()));
                    return (minPort <= maxSearch && maxPort >= minSearch);
                } else {
                    const searchPortNum = parseInt(searchTerm);
                    return !isNaN(searchPortNum) && searchPortNum >= minPort && searchPortNum <= maxPort;
                }
            }
            
            // Handle search with comma-separated ports (e.g., "80,443")
            if (searchTerm.includes(',')) {
                const searchPorts = searchTerm.split(',').map(p => p.trim());
                return searchPorts.includes(protocolPort.toString());
            }
            
            return protocolPort.toString().includes(searchTerm);
        }

        // Render protocol cards based on current filter, search, and page
        function renderProtocolCards() {
            const protocolCards = document.getElementById('protocolCards');
            
            debug(`Rendering protocol cards with filter: "${appState.currentFilter}" and search: "${appState.searchTerm}"`);
            
            // Clear the container completely before adding new cards
            protocolCards.innerHTML = '';
            
            // Get filtered protocols
            const filteredProtocols = getFilteredProtocols();
            
            debug(`Filter results: ${filteredProtocols.length} protocols match current criteria`);
            
            // Display message if no results
            if (filteredProtocols.length === 0) {
                protocolCards.innerHTML = `
                    <div class="no-results section-animate">
                        <i class="bx bx-search text-4xl mb-2 text-gray-500"></i>
                        <h3 class="text-xl font-semibold mb-2">No protocols found</h3>
                        <p class="text-gray-400">Try changing your search or filter criteria</p>
                    </div>
                `;
                
                // Hide pagination if no results
                document.getElementById('paginationContainer').style.display = 'none';
                
                debug('No results found, displaying empty state');
                return;
            }
            
            // Calculate pagination
            const totalPages = Math.ceil(filteredProtocols.length / appState.itemsPerPage);
            
            // Adjust current page if it's out of bounds after filtering
            if (appState.currentPage > totalPages) {
                appState.currentPage = totalPages;
            }
            
            // Calculate start and end indices for current page
            const startIndex = (appState.currentPage - 1) * appState.itemsPerPage;
            const endIndex = Math.min(startIndex + appState.itemsPerPage, filteredProtocols.length);
            
            // Create and append protocol cards for current page
            for (let i = startIndex; i < endIndex; i++) {
                const card = createProtocolCard(filteredProtocols[i], i - startIndex);
                protocolCards.appendChild(card);
            }
            
            // Update pagination UI
            updatePagination(totalPages);
            
            // Trigger animations for newly added cards
            setTimeout(() => {
                document.querySelectorAll('.protocol-card').forEach((card, index) => {
                    setTimeout(() => {
                        card.classList.add('visible');
                        
                        // Restore expanded state if needed
                        if (appState.expandedCards.has(card.id)) {
                            card.classList.add('expanded');
                            
                            // Also rotate the icon properly
                            const icon = card.querySelector('.expand-btn i');
                            if (icon) {
                                icon.style.transform = 'rotate(180deg)';
                            }
                            
                            // Make list items visible 
                            card.querySelectorAll('.list-item-animate').forEach((item, i) => {
                                setTimeout(() => {
                                    item.classList.add('list-item-visible');
                                }, 50 + (i * 20));
                            });
                        }
                    }, index * 100);
                });
            }, 50);
            
            // Update progress bars
            setTimeout(updateProgress, 100);
            
            debug('Protocol cards rendered successfully');
        }
        
        // Update pagination UI
        function updatePagination(totalPages) {
            const paginationContainer = document.getElementById('paginationContainer');
            paginationContainer.innerHTML = '';
            
            if (totalPages <= 1) {
                paginationContainer.style.display = 'none';
                return;
            }
            
            paginationContainer.style.display = 'flex';
            
            // Previous button
            const prevBtn = document.createElement('button');
            prevBtn.className = 'pagination-btn';
            prevBtn.innerHTML = '<i class="bx bx-chevron-left"></i>';
            prevBtn.disabled = appState.currentPage === 1;
            prevBtn.addEventListener('click', () => {
                if (appState.currentPage > 1) {
                    goToPage(appState.currentPage - 1);
                }
            });
            paginationContainer.appendChild(prevBtn);
            
            // Page numbers - adjust for mobile
            const maxVisiblePages = appState.isMobile ? 3 : 5;
            const pageButtonsToShow = [];
            
            // Always show first page
            pageButtonsToShow.push(1);
            
            // Calculate center range
            let rangeStart = Math.max(2, appState.currentPage - 1);
            let rangeEnd = Math.min(totalPages - 1, appState.currentPage + 1);
            
            // Adjust range if we're near the start or end
            if (rangeEnd - rangeStart + 1 < 3 && totalPages > 3) {
                if (appState.currentPage <= 2) {
                    rangeEnd = Math.min(4, totalPages - 1);
                } else if (appState.currentPage >= totalPages - 1) {
                    rangeStart = Math.max(2, totalPages - 3);
                }
            }
            
            // Add ellipsis if needed before center range
            if (rangeStart > 2) {
                pageButtonsToShow.push('...');
            }
            
            // Add center range
            for (let i = rangeStart; i <= rangeEnd; i++) {
                pageButtonsToShow.push(i);
            }
            
            // Add ellipsis if needed after center range
            if (rangeEnd < totalPages - 1) {
                pageButtonsToShow.push('...');
            }
            
            // Always show last page if there's more than one page
            if (totalPages > 1) {
                pageButtonsToShow.push(totalPages);
            }
            
            // For mobile, simplify further if needed
            if (appState.isMobile && pageButtonsToShow.length > 5) {
                // Show just first, current, and last
                pageButtonsToShow = [
                    1,
                    appState.currentPage > 2 ? '...' : null,
                    appState.currentPage !== 1 && appState.currentPage !== totalPages ? appState.currentPage : null,
                    appState.currentPage < totalPages - 1 ? '...' : null,
                    totalPages
                ].filter(item => item !== null);
            }
            
            // Create page buttons
            pageButtonsToShow.forEach(page => {
                if (page === '...') {
                    const ellipsis = document.createElement('span');
                    ellipsis.className = 'pagination-ellipsis';
                    ellipsis.textContent = '...';
                    paginationContainer.appendChild(ellipsis);
                } else {
                    const pageBtn = document.createElement('button');
                    pageBtn.className = `pagination-btn ${page === appState.currentPage ? 'active' : ''}`;
                    pageBtn.textContent = page;
                    pageBtn.addEventListener('click', () => goToPage(page));
                    paginationContainer.appendChild(pageBtn);
                }
            });
            
            // Next button
            const nextBtn = document.createElement('button');
            nextBtn.className = 'pagination-btn';
            nextBtn.innerHTML = '<i class="bx bx-chevron-right"></i>';
            nextBtn.disabled = appState.currentPage === totalPages;
            nextBtn.addEventListener('click', () => {
                if (appState.currentPage < totalPages) {
                    goToPage(appState.currentPage + 1);
                }
            });
            paginationContainer.appendChild(nextBtn);
        }
        
        // Navigate to a specific page
        function goToPage(page) {
            appState.currentPage = page;
            renderProtocolCards();
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        }
        
        // Create a single protocol card element
        function createProtocolCard(protocol, index) {
            const card = document.createElement('div');
            card.className = 'protocol-card glass-card section-animate relative';
            card.id = protocol.id;
            card.setAttribute('data-index', index);
            card.style.animationDelay = `${index * 0.1}s`;
            
            const categoryColor = getCategoryColor(protocol.category);
            
            // Calculate completion percentage for this card
            const totalItems = protocol.vulnerabilities.length + protocol.testing.length + protocol.tools.length;
            let checkedCount = 0;
            
            // Count checked vulnerabilities
            protocol.vulnerabilities.forEach((_, i) => {
                if (appState.checkedItems[`${protocol.id}-vulnerability-${i}`]) checkedCount++;
            });
            
            // Count checked testing procedures
            protocol.testing.forEach((_, i) => {
                if (appState.checkedItems[`${protocol.id}-testing-${i}`]) checkedCount++;
            });
            
            // Count checked tools
            protocol.tools.forEach((_, i) => {
                if (appState.checkedItems[`${protocol.id}-tool-${i}`]) checkedCount++;
            });
            
            // Calculate percentage
            const percentage = totalItems > 0 ? Math.round((checkedCount / totalItems) * 100) : 0;
            
            // Format port display for multiple ports
            let portDisplay = getPortDisplay(protocol.port);
            
            card.innerHTML = `
                <div class="category-indicator" style="background: ${categoryColor}"></div>
                <div class="card-header p-6 flex flex-col md:flex-row md:items-center justify-between" data-id="${protocol.id}">
                    <div>
                        <div class="flex items-center mb-2 flex-wrap">
                            <h2 class="text-2xl font-bold">${protocol.name}</h2>
                            <span class="ml-3 text-sm px-3 py-1 rounded-full glass-inset">${portDisplay}</span>
                            <span class="category-badge ml-3 mt-1 md:mt-0" style="background: ${categoryColor}">${protocol.category}</span>
                        </div>
                        <p class="text-gray-400">${protocol.description}</p>
                    </div>
                    <div class="flex items-center mt-4 md:mt-0">
                        <div class="mr-4 relative">
                            <div class="text-sm text-gray-400 mb-1">Completion</div>
                            <div class="progress-container w-32">
                                <div class="progress-bar" data-protocol="${protocol.id}" style="width: ${percentage}%"></div>
                                <div class="completion-percentage">${percentage}%</div>
                            </div>
                        </div>
                        <button class="expand-btn bg-gray-800 hover:bg-gray-700 p-2 rounded-full transition-all duration-300">
                            <i class="bx bx-chevron-down text-2xl transition-transform duration-300"></i>
                        </button>
                    </div>
                </div>
                <div class="card-content">
                    <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mt-4">
                        <div class="glass-inset p-4 content-section" style="transition-delay: 0.1s">
                            <h3 class="text-lg font-semibold mb-3 flex items-center">
                                <i class="bx bx-shield-quarter text-red-500 mr-2"></i>
                                Vulnerabilities
                            </h3>
                            <ul class="space-y-3">
                                ${protocol.vulnerabilities.map((vulnerability, i) => `
                                    <li class="flex items-start list-item-animate" style="transition-delay: ${i * 50}ms">
                                        <label class="toggle-container inline-flex mr-2 mt-0.5">
                                            <input type="checkbox" class="toggle-input vulnerability-check" 
                                                data-protocol="${protocol.id}" 
                                                data-type="vulnerability" 
                                                data-index="${i}"
                                                ${appState.checkedItems[`${protocol.id}-vulnerability-${i}`] ? 'checked' : ''}>
                                            <span class="toggle-slider"></span>
                                        </label>
                                        <span class="checkmark-animate ${appState.checkedItems[`${protocol.id}-vulnerability-${i}`] ? 'line-through text-gray-500' : ''}">${vulnerability}</span>
                                    </li>
                                `).join('')}
                            </ul>
                        </div>
                        <div class="glass-inset p-4 content-section" style="transition-delay: 0.2s">
                            <h3 class="text-lg font-semibold mb-3 flex items-center">
                                <i class="bx bx-test-tube text-yellow-500 mr-2"></i>
                                Testing Procedures
                            </h3>
                            <ul class="space-y-3">
                                ${protocol.testing.map((test, i) => `
                                    <li class="flex items-start list-item-animate" style="transition-delay: ${i * 50}ms">
                                        <label class="toggle-container inline-flex mr-2 mt-0.5">
                                            <input type="checkbox" class="toggle-input testing-check" 
                                                data-protocol="${protocol.id}" 
                                                data-type="testing" 
                                                data-index="${i}"
                                                ${appState.checkedItems[`${protocol.id}-testing-${i}`] ? 'checked' : ''}>
                                            <span class="toggle-slider"></span>
                                        </label>
                                        <span class="checkmark-animate ${appState.checkedItems[`${protocol.id}-testing-${i}`] ? 'line-through text-gray-500' : ''}">${test}</span>
                                    </li>
                                `).join('')}
                            </ul>
                        </div>
                        <div class="glass-inset p-4 content-section" style="transition-delay: 0.3s">
                            <h3 class="text-lg font-semibold mb-3 flex items-center">
                                <i class="bx bx-wrench text-blue-500 mr-2"></i>
                                Tools
                            </h3>
                            <ul class="space-y-3">
                                ${protocol.tools.map((tool, i) => `
                                    <li class="flex items-start list-item-animate" style="transition-delay: ${i * 50}ms">
                                        <label class="toggle-container inline-flex mr-2 mt-0.5">
                                            <input type="checkbox" class="toggle-input tool-check" 
                                                data-protocol="${protocol.id}" 
                                                data-type="tool" 
                                                data-index="${i}"
                                                ${appState.checkedItems[`${protocol.id}-tool-${i}`] ? 'checked' : ''}>
                                            <span class="toggle-slider"></span>
                                        </label>
                                        <span class="checkmark-animate ${appState.checkedItems[`${protocol.id}-tool-${i}`] ? 'line-through text-gray-500' : ''}">${tool}</span>
                                    </li>
                                `).join('')}
                            </ul>
                        </div>
                    </div>
                </div>
            `;
            
            return card;
        }

        // Filter protocols by category
        function filterByCategory(category) {
            debug(`Filtering to category: "${category}" (previous: "${appState.currentFilter}")`);
            
            // Update state
            appState.currentFilter = category;
            appState.currentPage = 1; // Reset to first page on category change
            
            // Update UI - category filters
            document.querySelectorAll('.category-filter').forEach(btn => {
                if (btn.getAttribute('data-category') === category) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            
            // Filter protocol navigation items in the sidebar
            document.querySelectorAll('.protocol-nav-item').forEach(item => {
                if (category === 'all' || item.getAttribute('data-category') === category) {
                    item.classList.remove('hidden');
                } else {
                    item.classList.add('hidden');
                }
            });
            
            // Force reflow before rendering to prevent race conditions
            document.body.offsetHeight;
            
            // Render new protocol cards
            renderProtocolCards();
            
            // Auto-scroll to first result
            setTimeout(() => {
                const firstCard = document.querySelector('.protocol-card');
                if (firstCard) {
                    window.scrollTo({
                        top: firstCard.offsetTop - 20,
                        behavior: 'smooth'
                    });
                }
            }, 100);
            
            debug(`Category filter applied: "${category}"`);
        }

        // Setup event listeners
        function setupEventListeners() {
            debug('Setting up event listeners...');
            
            // Mobile menu toggle
            document.getElementById('menuToggle').addEventListener('click', () => {
                document.getElementById('sidebar').classList.add('open');
                debug('Mobile menu opened');
            });
            
            document.getElementById('mobileClose').addEventListener('click', () => {
                document.getElementById('sidebar').classList.remove('open');
                debug('Mobile menu closed');
            });
            
            // Search functionality with debounce
            const debounce = (func, delay) => {
                let timeout;
                return function() {
                    const context = this;
                    const args = arguments;
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func.apply(context, args), delay);
                };
            };
            
            document.getElementById('search').addEventListener('input', debounce((e) => {
                appState.searchTerm = e.target.value.trim();
                appState.currentPage = 1; // Reset to first page when search changes
                debug(`Search term updated: "${appState.searchTerm}"`);
                renderProtocolCards();
            }, 300));
            
            // Card expansion
            document.addEventListener('click', (e) => {
                if (e.target.closest('.card-header') || e.target.closest('.expand-btn')) {
                    const card = e.target.closest('.protocol-card');
                    if (card) {
                        toggleCardExpansion(card);
                    }
                }
            });
            
            // Keyboard navigation for pagination
            document.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowLeft' && appState.currentPage > 1) {
                    goToPage(appState.currentPage - 1);
                } else if (e.key === 'ArrowRight') {
                    const totalPages = Math.ceil(getFilteredProtocols().length / appState.itemsPerPage);
                    if (appState.currentPage < totalPages) {
                        goToPage(appState.currentPage + 1);
                    }
                }
            });
            
            // Checkbox handling
            document.addEventListener('change', (e) => {
                if (e.target.classList.contains('toggle-input')) {
                    const protocol = e.target.getAttribute('data-protocol');
                    const type = e.target.getAttribute('data-type');
                    const index = e.target.getAttribute('data-index');
                    const key = `${protocol}-${type}-${index}`;
                    
                    // Update checked state
                    appState.checkedItems[key] = e.target.checked;
                    debug(`Checkbox changed: ${key} = ${e.target.checked}`);
                    
                    // Save to localStorage
                    localStorage.setItem('checkedItems', JSON.stringify(appState.checkedItems));
                    
                    // Update text styling
                    const textElement = e.target.closest('li').querySelector('span:not(.toggle-slider)');
                    if (e.target.checked) {
                        textElement.classList.add('line-through', 'text-gray-500');
                    } else {
                        textElement.classList.remove('line-through', 'text-gray-500');
                    }
                    
                    // Update progress
                    updateProgress();
                }
            });
            
            // Category filter clicks
            document.getElementById('categoryFilters').addEventListener('click', (e) => {
                const categoryBtn = e.target.closest('.category-filter');
                if (categoryBtn) {
                    const category = categoryBtn.getAttribute('data-category');
                    debug(`Category filter clicked: "${category}"`);
                    filterByCategory(category);
                }
            });
            
            // Protocol navigation clicks
            document.getElementById('protocolNav').addEventListener('click', (e) => {
                const protocolItem = e.target.closest('[data-protocol-id]');
                if (protocolItem) {
                    const id = protocolItem.getAttribute('data-protocol-id');
                    debug(`Protocol navigation clicked: ${id}`);
                    scrollToProtocol(id);
                    
                    // Close sidebar on mobile
                    if (window.innerWidth < 1024) {
                        document.getElementById('sidebar').classList.remove('open');
                    }
                }
            });
            
            // Scroll animations
            window.addEventListener('scroll', debounce(handleScrollAnimations, 100));
            
            // Close sidebar when clicking outside on mobile
            document.addEventListener('click', (e) => {
                if (window.innerWidth < 1024 && 
                    document.getElementById('sidebar').classList.contains('open') &&
                    !e.target.closest('#sidebar') && 
                    !e.target.closest('#menuToggle')) {
                    document.getElementById('sidebar').classList.remove('open');
                }
            });
            
            // Window resize handler for pagination adjustments
            window.addEventListener('resize', debounce(() => {
                // Update mobile state
                const wasMobile = appState.isMobile;
                appState.isMobile = window.innerWidth < 768;
                
                // Only update if state changed
                if (wasMobile !== appState.isMobile) {
                    // Recalculate items per page based on screen size
                    if (appState.isMobile) {
                        appState.itemsPerPage = 3;
                    } else if (window.innerWidth < 1280) {
                        appState.itemsPerPage = 4;
                    } else {
                        appState.itemsPerPage = 5;
                    }
                    
                    // Re-render without changing page
                    renderProtocolCards();
                }
            }, 250));
            
            debug('Event listeners setup complete');
        }

        // Add this utility function somewhere in your script
        function animateElement(element, keyframes, options) {
            // Check if Web Animations API is supported
            if ('animate' in element) {
                // Use reduced motion setting if user prefers it
                if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                    options.duration = options.duration / 2;
                }
                
                return element.animate(keyframes, options);
            } else {
                // Fallback for browsers without Web Animations API
                const animation = { finished: Promise.resolve() };
                
                // Apply the first keyframe immediately
                const firstFrame = keyframes[0];
                Object.keys(firstFrame).forEach(property => {
                    element.style[property] = firstFrame[property];
                });
                
                // Use setTimeout to apply the last keyframe
                setTimeout(() => {
                    const lastFrame = keyframes[keyframes.length - 1];
                    Object.keys(lastFrame).forEach(property => {
                        element.style[property] = lastFrame[property];
                    });
                }, options.duration || 300);
                
                return animation;
            }
        }

        // Enhanced toggleCardExpansion function with advanced animation
        function toggleCardExpansion(card) {
            if (!card) return;
            
            const wasExpanded = card.classList.contains('expanded');
            const icon = card.querySelector('.expand-btn i');
            const id = card.id;
            const cardContent = card.querySelector('.card-content');
            
            debug(`Toggling card expansion: ${id} (was expanded: ${wasExpanded})`);
            
            // Handle expand/collapse state tracking
            if (wasExpanded) {
                appState.expandedCards.delete(id);
            } else {
                appState.expandedCards.add(id);
            }
            
            // Use the Web Animations API for smoother animation
            if (wasExpanded) {
                // 1. Animate content sections out
                const sections = card.querySelectorAll('.content-section');
                sections.forEach((section, index) => {
                    animateElement(section, [
                        { opacity: 1, transform: 'translateY(0)' },
                        { opacity: 0, transform: 'translateY(15px)' }
                    ], {
                        duration: 200,
                        easing: 'cubic-bezier(0.4, 0, 0.2, 1)',
                        fill: 'forwards',
                        delay: index * 30
                    });
                });
                
                // 2. Animate icon rotation
                animateElement(icon, [
                    { transform: 'rotate(180deg)' },
                    { transform: 'rotate(0deg)' }
                ], {
                    duration: 300,
                    easing: 'cubic-bezier(0.34, 1.56, 0.64, 1)',
                    fill: 'forwards'
                });
                
                // 3. Wait a bit then collapse the card content
                setTimeout(() => {
                    card.classList.remove('expanded');
                    
                    // Smooth animation with GPU acceleration
                    animateElement(cardContent, [
                        { opacity: 1, maxHeight: `${cardContent.scrollHeight}px`, transform: 'translateY(0)' },
                        { opacity: 0, maxHeight: '0px', transform: 'translateY(10px)' }
                    ], {
                        duration: 300,
                        easing: 'cubic-bezier(0.4, 0, 0.2, 1)',
                        fill: 'forwards'
                    });
                }, 80);
                
            } else {
                // 1. Expand the card
                card.classList.add('expanded');
                
                // 2. Animate content expansion
                animateElement(cardContent, [
                    { opacity: 0, maxHeight: '0px', transform: 'translateY(10px)' },
                    { opacity: 1, maxHeight: '2000px', transform: 'translateY(0)' }
                ], {
                    duration: appState.isMobile ? 400 : 500,
                    easing: 'cubic-bezier(0.16, 1, 0.3, 1)',
                    fill: 'forwards'
                });
                
                // 3. Animate icon rotation
                animateElement(icon, [
                    { transform: 'rotate(0deg)' },
                    { transform: 'rotate(180deg)' }
                ], {
                    duration: 400,
                    easing: 'cubic-bezier(0.34, 1.56, 0.64, 1)',
                    fill: 'forwards'
                });
                
                // 4. Animate content sections in with staggered delay
                const sections = card.querySelectorAll('.content-section');
                const sectionDelay = appState.isMobile ? 80 : 150;
                
                sections.forEach((section, index) => {
                    animateElement(section, [
                        { opacity: 0, transform: 'translateY(15px)' },
                        { opacity: 1, transform: 'translateY(0)' }
                    ], {
                        duration: 400,
                        easing: 'cubic-bezier(0.16, 1, 0.3, 1)',
                        fill: 'forwards',
                        delay: sectionDelay + (index * 80)
                    });
                });
                
                // 5. Animate list items with staggered delay
                const listItems = card.querySelectorAll('.list-item-animate');
                const itemDelay = appState.isMobile ? 10 : 30;
                
                listItems.forEach((item, index) => {
                    animateElement(item, [
                        { opacity: 0, transform: 'translateX(20px)' },
                        { opacity: 1, transform: 'translateX(0)' }
                    ], {
                        duration: 400,
                        easing: 'cubic-bezier(0.34, 1.56, 0.64, 1)',
                        fill: 'forwards',
                        delay: 200 + (index * itemDelay)
                    });
                });
            }
        }

        // Scroll to a specific protocol
        function scrollToProtocol(id) {
            // First, ensure we're displaying the right category if needed
            const protocol = protocolData.find(p => p.id === id);
            if (!protocol) {
                debug(`Protocol not found: ${id}`);
                return;
            }
            
            // If we're filtering by category and the protocol isn't in the current category,
            // change to the correct category
            if (appState.currentFilter !== 'all' && protocol.category !== appState.currentFilter) {
                filterByCategory(protocol.category);
            }
            
            // Find which page contains this protocol
            const filteredProtocols = getFilteredProtocols();
            const protocolIndex = filteredProtocols.findIndex(p => p.id === id);
            
            if (protocolIndex === -1) {
                debug(`Protocol ${id} not found in filtered results`);
                return;
            }
            
            // Calculate which page the protocol is on
            const targetPage = Math.floor(protocolIndex / appState.itemsPerPage) + 1;
            
            // If we're not on the right page, go there first
            if (targetPage !== appState.currentPage) {
                appState.currentPage = targetPage;
                renderProtocolCards();
            }
            
            // Now try to find the protocol card and scroll to it
            setTimeout(() => {
                const element = document.getElementById(id);
                if (!element) {
                    debug(`Protocol element not found in DOM: ${id}`);
                    return;
                }
                
                debug(`Scrolling to protocol: ${id}`);
                
                window.scrollTo({
                    top: element.offsetTop - 20,
                    behavior: 'smooth'
                });
                
                // Highlight and expand the card
                setTimeout(() => {
                    // Track this card as expanded
                    appState.expandedCards.add(id);
                    
                    // Expand the card with animation
                    toggleCardExpansion(element);
                    
                    // Add and remove highlight effect
                    element.style.boxShadow = `0 0 25px rgba(139, 92, 246, 0.5)`;
                    setTimeout(() => {
                        element.style.boxShadow = '';
                    }, 2000);
                }, 300);
            }, 100);
        }

        // Update progress bars
        function updateProgress() {
            debug('Updating progress bars');
            
            protocolData.forEach(protocol => {
                const totalItems = protocol.vulnerabilities.length + protocol.testing.length + protocol.tools.length;
                let checkedCount = 0;
                
                // Count checked vulnerabilities
                protocol.vulnerabilities.forEach((_, i) => {
                    if (appState.checkedItems[`${protocol.id}-vulnerability-${i}`]) checkedCount++;
                });
                
                // Count checked testing procedures
                protocol.testing.forEach((_, i) => {
                    if (appState.checkedItems[`${protocol.id}-testing-${i}`]) checkedCount++;
                });
                
                // Count checked tools
                protocol.tools.forEach((_, i) => {
                    if (appState.checkedItems[`${protocol.id}-tool-${i}`]) checkedCount++;
                });
                
                // Calculate percentage
                const percentage = totalItems > 0 ? Math.round((checkedCount / totalItems) * 100) : 0;
                
                // Update protocol progress bar with smooth animation
                const progressBars = document.querySelectorAll(`.progress-bar[data-protocol="${protocol.id}"]`);
                progressBars.forEach(bar => {
                    animateElement(bar, [
                        { width: bar.style.width || '0%' },
                        { width: `${percentage}%` }
                    ], {
                        duration: 500,
                        easing: 'cubic-bezier(0.22, 1, 0.36, 1)',
                        fill: 'forwards'
                    });
                    
                    // Update percentage text if present
                    const percentageText = bar.closest('.progress-container').querySelector('.completion-percentage');
                    if (percentageText) {
                        percentageText.textContent = `${percentage}%`;
                    }
                });
            });
        }

        // Initialize animations
        function initializeAnimations() {
            debug('Initializing animations');
            
            // Stagger the initial card animations
            document.querySelectorAll('.protocol-card').forEach((card, index) => {
                // Use less delay on mobile for snappier response
                const delay = appState.isMobile ? 50 : 100;
                card.style.transitionDelay = `${index * 0.1}s`;
                
                setTimeout(() => {
                    card.classList.add('visible');
                }, delay + (index * delay));
            });
            
            // Trigger section animations that are initially visible
            handleScrollAnimations();
        }

        // Handle scroll-triggered animations
        function handleScrollAnimations() {
            const elements = document.querySelectorAll('.section-animate:not(.visible)');
            
            elements.forEach(element => {
                const elementTop = element.getBoundingClientRect().top;
                const elementBottom = element.getBoundingClientRect().bottom;
                
                // Check if element is in viewport
                if (elementTop < window.innerHeight - 100 && elementBottom > 0) {
                    element.classList.add('visible');
                    
                    // If it's a protocol card, animate its list items
                    if (element.classList.contains('protocol-card') && element.classList.contains('expanded')) {
                        element.querySelectorAll('.list-item-animate').forEach((item, index) => {
                            setTimeout(() => {
                                item.classList.add('list-item-visible');
                            }, index * 30);
                        });
                    }
                }
            });
        }

        // Get color for a category
        function getCategoryColor(category) {
            // Static color mapping for common categories
            const predefinedColors = {
                'file': 'linear-gradient(135deg, #3B82F6 0%, #1D4ED8 100%)',
                'remote': 'linear-gradient(135deg, #EC4899 0%, #BE185D 100%)',
                'mail': 'linear-gradient(135deg, #10B981 0%, #059669 100%)',
                'network': 'linear-gradient(135deg, #8B5CF6 0%, #6D28D9 100%)',
                'web': 'linear-gradient(135deg, #F59E0B 0%, #D97706 100%)',
                'database': 'linear-gradient(135deg, #0EA5E9 0%, #0369A1 100%)'
            };
            
            // If we have a predefined color, use it
            if (predefinedColors[category]) {
                return predefinedColors[category];
            }
            
            // Otherwise, generate a color deterministically based on the category name
            // This ensures the same category always gets the same color
            return generateColorFromString(category);
        }

        // Generate a gradient color based on a string input
        function generateColorFromString(str) {
            // Create a hash from the string
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = str.charCodeAt(i) + ((hash << 5) - hash);
            }
            
            // Generate primary color
            const h1 = Math.abs(hash) % 360; // Hue (0-359)
            const s1 = 70 + (Math.abs(hash >> 8) % 20); // Saturation (70-90%)
            const l1 = 45 + (Math.abs(hash >> 16) % 10); // Lightness (45-55%)
            
            // Generate a complementary color for the gradient (shifted hue)
            const h2 = (h1 + 20) % 360;
            const s2 = s1 - 10;
            const l2 = l1 - 10;
            
            // Return a gradient
            return `linear-gradient(135deg, 
                hsl(${h1}, ${s1}%, ${l1}%) 0%, 
                hsl(${h2}, ${s2}%, ${l2}%) 100%)`;
        }
        
        // Update progress on initial load
        window.addEventListener('load', () => {
            setTimeout(updateProgress, 300);
        });
    </script>
</body>
</html>
