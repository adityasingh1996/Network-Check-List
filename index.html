html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SecureCheck - Protocol Checklist</title>

    <!-- Performance: Preconnect to Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    <!-- Performance: Load Google Fonts via Link (Optimized Weights) -->
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;600;700&display=swap" rel="stylesheet">

    <!-- Other CSS Libraries -->
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/boxicons@2.1.4/css/boxicons.min.css">

    <style>
        /* --- Your existing CSS --- */
        :root {
            --primary: #8b5cf6;
            --primary-dark: #7c3aed;
            --primary-light: #a78bfa;
            --primary-alpha: rgba(139, 92, 246, 0.2);
            --secondary: #10b981; /* Added for copy success feedback */
            --secondary-alpha: rgba(16, 185, 129, 0.2);
            --dark: #0f172a;
            --darker: #020617;
            --light: #f8fafc;
            --neutral: #64748b;
            --glass-light: rgba(255, 255, 255, 0.05);
            --glass-dark: rgba(0, 0, 0, 0.2);
            --card-bg: rgba(15, 23, 42, 0.7);
            --sidebar-bg: rgba(2, 6, 23, 0.85); /* Default transparent bg for desktop */
            --sidebar-bg-solid: var(--darker); /* Solid fallback for mobile */
            /* --glow: 0 0 15px rgba(139, 92, 246, 0.6);  REMOVED - Glow is dynamic */
            --transition-smooth: 0.5s cubic-bezier(0.33, 1, 0.68, 1);
        }
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Manrope', system-ui, -apple-system, sans-serif; }
        html { scroll-behavior: smooth; }
        /* Removed background animation, simplified background */
        body { background: var(--darker); color: var(--light); min-height: 100vh; overflow-x: hidden; background-image: radial-gradient(circle at 10% 20%, rgba(139, 92, 246, 0.03) 0%, transparent 15%), radial-gradient(circle at 90% 80%, rgba(16, 185, 129, 0.03) 0%, transparent 15%), radial-gradient(circle at 50% 50%, rgba(15, 23, 42, 0.8) 0%, var(--darker) 100%); }

        /* Base Glass Styles */
        .glass-effect { backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px); border: 1px solid rgba(255, 255, 255, 0.05); box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2); }
        .glass-dark-effect { border: 1px solid rgba(255, 255, 255, 0.03); box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3); }
        .glass-inset-effect { backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); box-shadow: inset 2px 2px 5px rgba(0, 0, 0, 0.5), inset -2px -2px 5px rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.03); }
        .glass-card { background: var(--card-bg); border-radius: 16px; transition: all var(--transition-smooth), box-shadow 0.4s ease, transform 0.4s ease; /* Adjusted base transition */ }
        .glass-card:hover { box-shadow: 0 12px 40px rgba(0, 0, 0, 0.3), 0 0 20px rgba(139, 92, 246, 0.2); transform: translateY(-3px); }
        .glass-inset { background: rgba(2, 6, 23, 0.5); border-radius: 16px; }

        /* Apply glass effects by default (desktop first) */
        .glass-card { backdrop-filter: blur(px); -webkit-backdrop-filter: blur(16px); border: 1px solid rgba(255, 255, 255, 0.05); box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2); }
        .glass-inset { backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); box-shadow: inset 2px 2px 5px rgba(0, 0, 0, 0.5), inset -2px -2px 5px rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.03); }

        /* Background Animation Rules REMOVED */

        /* Sidebar Styling */
        .sidebar { background: var(--sidebar-bg); height: 100vh; position: fixed; top: 0; left: 0; padding: 2rem 1.5rem; width: 300px; z-index: 50; transition: transform 0.6s cubic-bezier(0.22, 1, 0.36, 1), background-color 0.3s ease; border-right: 1px solid rgba(255, 255, 255, 0.03); display: flex; flex-direction: column; overflow-y: hidden; }
        @media (min-width: 1025px) { .sidebar.glass-dark-effect { backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px); border-color: rgba(255, 255, 255, 0.03); box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3); } }
        @media (max-width: 1024px) { .sidebar { transform: translateX(-100%); background: var(--sidebar-bg-solid) !important; backdrop-filter: none !important; -webkit-backdrop-filter: none !important; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3); } .sidebar.open { transform: translateX(0); } }

        /* Content Area */
        .content-area { margin-left: 300px; padding: 2rem; min-height: 100vh; transition: margin-left 0.6s cubic-bezier(0.22, 1, 0.36, 1); position: relative; z-index: 1; }
        @media (max-width: 1024px) { .content-area { margin-left: 0; width: 100%; } }
        @media (max-width: 768px) { .content-area { padding: 1.5rem 1rem; } header h1 { font-size: 1.75rem !important; } .card-header { flex-direction: column !important; align-items: flex-start !important; padding: 1.5rem 1rem !important; } .card-header > div:last-child { width: 100%; justify-content: space-between; margin-top: 1rem; } .progress-container { width: 100% !important; } #protocolCards { min-height: 200px; } }

        /* Protocol Card & Content */
        .protocol-card { transition: opacity 0.6s cubic-bezier(0.22, 1, 0.36, 1), transform 0.6s cubic-bezier(0.22, 1, 0.36, 1), box-shadow 0.4s ease; transform-style: preserve-3d; perspective: 1000px; overflow: hidden; transform: translateZ(0); backface-visibility: hidden; opacity: 0; }
        .card-header { cursor: pointer; transition: background-color 0.4s ease; }
        .card-content { max-height: 0; overflow: hidden; padding: 0 20px 0 20px; transition: max-height 0.6s cubic-bezier(0.16, 1, 0.3, 1), opacity 0.4s cubic-bezier(0.16, 1, 0.3, 1), padding 0.6s cubic-bezier(0.16, 1, 0.3, 1), transform 0.6s cubic-bezier(0.16, 1, 0.3, 1); opacity: 0; visibility: hidden; transform: translateY(10px); transform-origin: top; }
        .protocol-card.expanded .card-content { max-height: 2000px; opacity: 1; visibility: visible; padding: 0 20px 20px 20px; transform: translateY(0); }

        /* Toggle Switch */
        .toggle-container { position: relative; width: 50px; height: 26px; flex-shrink: 0; min-width: 50px; } .toggle-input { opacity: 0; width: 0; height: 0; } .toggle-slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(15, 23, 42, 0.7); transition: all 0.4s cubic-bezier(0.22, 1, 0.36, 1); border-radius: 34px; box-shadow: inset 2px 2px 4px var(--glass-dark), inset -2px -2px 4px var(--glass-light); overflow: hidden; } .toggle-slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 4px; bottom: 4px; background: var(--light); transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1); border-radius: 50%; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3); z-index: 2; } .toggle-slider::after { content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%; background: linear-gradient(90deg, var(--primary-dark) 0%, var(--primary) 100%); transition: all 0.4s cubic-bezier(0.22, 1, 0.36, 1); opacity: 0; } .toggle-input:checked + .toggle-slider::after { left: 0; opacity: 1; } .toggle-input:checked + .toggle-slider:before { transform: translateX(24px); background: white; } .toggle-input:checked + .toggle-slider { box-shadow: 0 0 8px var(--primary-alpha); }
        .checkmark-animate { transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1); display: inline-block; /* Changed for better alignment with copy button */ vertical-align: top; margin-top: 0.1rem; } .toggle-input:checked ~ .checkmark-animate { transform: scale(1.1) rotate(5deg); }

        /* Progress Bar */
        .progress-container { width: 100%; height: 12px; background: rgba(15, 23, 42, 0.5); border-radius: 10px; box-shadow: inset 2px 2px 4px var(--glass-dark), inset -2px -2px 4px var(--glass-light); margin: 1rem 0; overflow: hidden; position: relative; } .progress-container::after { content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: linear-gradient(90deg, transparent 0%, rgba(255, 255, 255, 0.1) 50%, transparent 100%); opacity: 0.5; } .progress-bar { height: 100%; background: linear-gradient(90deg, var(--primary-dark), var(--primary), var(--primary-light)); border-radius: 10px; transition: width 1s cubic-bezier(0.22, 1, 0.36, 1); position: relative; overflow: hidden; width: 0; } .progress-bar::after { content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%; background: linear-gradient(90deg, transparent 0%, rgba(255, 255, 255, 0.2) 50%, transparent 100%); animation: progressShine 2s infinite; } @keyframes progressShine { to { left: 100%; } }
        .completion-percentage { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 0.75rem; font-weight: 600; color: white; text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5); opacity: 0; transition: opacity 0.3s ease; pointer-events: none; } .progress-container:hover .completion-percentage { opacity: 1; }

        /* Category Badge & Filters */
        .category-badge { display: inline-block; padding: 0.25rem 0.75rem; border-radius: 9999px; font-size: 0.75rem; font-weight: 600; letter-spacing: 0.05em; text-transform: uppercase; /* background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%); */ /* REMOVED - Background is dynamic */ box-shadow: 0 2px 10px rgba(139, 92, 246, 0.3); position: relative; overflow: hidden; color: white; } .category-badge::after { content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%; background: linear-gradient(90deg, rgba(255, 255, 255, 0) 0%, rgba(255, 255, 255, 0.3) 50%, rgba(255, 255, 255, 0) 100%); transform: skewX(-25deg); transition: all 0.8s ease; } @keyframes shine { 0% { left: -100%; } 100% { left: 100%; } }
        .category-filters { display: flex; gap: 0.75rem; flex-wrap: wrap; }
        .category-filter { padding: 0.4rem 1rem; border-radius: 9999px; cursor: pointer; transition: all 0.4s cubic-bezier(0.22, 1, 0.36, 1); background: rgba(15, 23, 42, 0.3); border: 1px solid rgba(255, 255, 255, 0.05); position: relative; overflow: hidden; font-weight: 500; font-size: 0.85rem; }
        .category-filter:hover { background: rgba(15, 23, 42, 0.5); transform: translateY(-2px); box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1); }
        .category-filter.active { background: var(--active-filter-bg, var(--primary)); box-shadow: 0 0 20px rgba(139, 92, 246, 0.3); transform: translateY(-2px); color: white; } /* Now uses CSS variable for active bg */
        .category-filter.active::after { content: ''; position: absolute; top: 0; left: -100%; width: 200%; height: 100%; background: linear-gradient(90deg, transparent 0%, rgba(255, 255, 255, 0.2) 50%, transparent 100%); animation: shine 3s infinite; }

        /* Animations & Scrollbar */
        .fade-in { animation: fadeIn 0.8s cubic-bezier(0.22, 1, 0.36, 1) forwards; opacity: 0; } @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } } .slide-in-right { animation: slideInRight 0.8s cubic-bezier(0.22, 1, 0.36, 1) forwards; } @keyframes slideInRight { from { transform: translateX(30px); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        ::-webkit-scrollbar { width: 8px; } ::-webkit-scrollbar-track { background: rgba(15, 23, 42, 0.2); border-radius: 10px; } ::-webkit-scrollbar-thumb { background: var(--primary-dark); border-radius: 10px; transition: all 0.3s ease; } ::-webkit-scrollbar-thumb:hover { background: var(--primary); box-shadow: 0 0 10px var(--primary); }
        .section-animate { transform: translateY(20px); transition: opacity 0.6s cubic-bezier(0.22, 1, 0.36, 1), transform 0.6s cubic-bezier(0.22, 1, 0.36, 1); } .section-animate.visible { opacity: 1; transform: translateY(0); } .protocol-card.section-animate { opacity: 0; } .protocol-card.section-animate.visible { opacity: 1; }
        .list-item-animate { opacity: 0; transform: translateX(20px); transition: all 0.5s cubic-bezier(0.22, 1, 0.36, 1); } .list-item-no-checkbox { margin-left: 0.5rem; padding-left: 0; }

        /* Search */
        .search-container { position: relative; margin-bottom: 1.25rem; } .search-input { width: 100%; padding: 0.75rem 1rem 0.75rem 3rem; border-radius: 12px; background: rgba(15, 23, 42, 0.3); border: 1px solid rgba(255, 255, 255, 0.05); color: var(--light); transition: all 0.4s cubic-bezier(0.22, 1, 0.36, 1); backdrop-filter: blur(4px); -webkit-backdrop-filter: blur(4px); } .search-input:focus { outline: none; box-shadow: 0 0 0 2px var(--primary-alpha), 0 0 15px rgba(139, 92, 246, 0.3); background: rgba(15, 23, 42, 0.5); border-color: rgba(139, 92, 246, 0.3); } .search-icon { position: absolute; left: 1rem; top: 50%; transform: translateY(-50%); color: var(--neutral); transition: color 0.3s ease; } .search-input:focus + .search-icon { color: var(--primary); }

        /* Sidebar Navigation */
        .nav-links { flex: 1; overflow-y: auto; padding-right: 5px; margin-bottom: 1rem; max-height: calc(100vh - 130px); /* Adjusted for potential search bar height */ }
        .protocol-nav-item { position: relative; overflow: hidden; padding-left: 1rem; margin-bottom: 0.6rem; border-radius: 12px; transition: all 0.4s cubic-bezier(0.22, 1, 0.36, 1); padding-top: 0.75rem; padding-bottom: 0.75rem; padding-right: 0.75rem; }
        .protocol-nav-item::before { content: ''; position: absolute; left: 0; top: 0; bottom: 0; width: 4px; background: var(--nav-item-color, var(--primary)); border-top-left-radius: inherit; border-bottom-left-radius: inherit; } /* Uses CSS variable for color */
        .protocol-nav-item:hover { transform: translateX(5px); background: rgba(15, 23, 42, 0.8) !important; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1), 0 0 5px rgba(139, 92, 246, 0.2); }
        .protocol-nav-item.hidden { display: none; }

        /* Misc UI Elements */
        #mainCategoryFiltersContainer { margin-bottom: 1.5rem; md:margin-bottom: 2rem; }
        .category-indicator { position: absolute; left: 0; top: 0; bottom: 0; width: 4px; border-top-left-radius: 16px; border-bottom-left-radius: 16px; } /* Background is set dynamically */
        .expand-btn { position: relative; overflow: hidden; transition: all 0.4s cubic-bezier(0.22, 1, 0.36, 1); } .expand-btn:hover { box-shadow: 0 0 15px rgba(139, 92, 246, 0.3); transform: translateY(-2px); } .expand-btn::after { content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: radial-gradient(circle, rgba(139, 92, 246, 0.2) 0%, transparent 70%); opacity: 0; transition: opacity 0.3s ease; } .expand-btn:hover::after { opacity: 1; } .expand-btn i { transition: transform 0.5s cubic-bezier(0.22, 1, 0.36, 1); }
        .no-results { text-align: center; padding: 3rem; background: rgba(15, 23, 42, 0.5); border-radius: 1rem; margin: 2rem 0; backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.03); box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1); transition: all 0.5s cubic-bezier(0.22, 1, 0.36, 1); } .no-results:hover { box-shadow: 0 15px 40px rgba(0, 0, 0, 0.2), 0 0 20px rgba(139, 92, 246, 0.1); transform: translateY(-5px); }
        .logo { position: relative; display: inline-block; } .logo::after { content: ''; position: absolute; left: 0; right: 0; bottom: -3px; height: 2px; background: linear-gradient(90deg, var(--primary-dark), var(--primary), var(--primary-dark)); transform: scaleX(0); transform-origin: left; transition: transform 0.6s cubic-bezier(0.22, 1, 0.36, 1); } .logo:hover::after { transform: scaleX(1); }
        .menu-toggle { transition: all 0.4s cubic-bezier(0.22, 1, 0.36, 1); z-index: 60; } .menu-toggle:hover { transform: rotate(90deg); box-shadow: 0 0 15px rgba(139, 92, 246, 0.3); }
        .content-section { transition: opacity 0.5s cubic-bezier(0.22, 1, 0.36, 1), transform 0.5s cubic-bezier(0.22, 1, 0.36, 1); transform: translateY(20px); opacity: 0; } .protocol-card.expanded .content-section { transform: translateY(0); opacity: 1; }
        li.list-item-animate { transition: background 0.3s ease, transform 0.3s ease, opacity 0.5s cubic-bezier(0.22, 1, 0.36, 1), transform 0.5s cubic-bezier(0.22, 1, 0.36, 1); border-radius: 8px; padding: 0.5rem; align-items: flex-start; } li.list-item-animate:hover:not(.list-item-no-checkbox-container) { background: rgba(255, 255, 255, 0.05); transform: translateX(5px) translateY(0); } li.list-item-no-checkbox-container:hover { background: transparent; transform: none; }
        .protocol-section h2 { margin-bottom: 0.75rem; font-size: 1.1rem; }

        /* Pagination */
        .pagination-container { display: flex; justify-content: center; align-items: center; margin-top: 2rem; gap: 0.5rem; flex-wrap: wrap; } .pagination-btn { display: flex; align-items: center; justify-content: center; width: 40px; height: 40px; border-radius: 50%; background: rgba(15, 23, 42, 0.3); border: 1px solid rgba(255, 255, 255, 0.05); color: var(--light); font-weight: 500; cursor: pointer; transition: all 0.3s ease; } .pagination-btn:hover:not(:disabled) { background: rgba(15, 23, 42, 0.5); box-shadow: 0 0 15px rgba(139, 92, 246, 0.2); transform: translateY(-2px); } .pagination-btn.active { background: var(--primary); color: white; font-weight: 600; box-shadow: 0 0 20px rgba(139, 92, 246, 0.3); } .pagination-btn:disabled { opacity: 0.5; cursor: not-allowed; } .pagination-ellipsis { display: flex; align-items: center; justify-content: center; width: 40px; height: 40px; color: var(--neutral); }

        /* Badges & Code */
        .port-badge { font-family: 'Courier New', monospace; background: rgba(15, 23, 42, 0.5); padding: 0.2rem 0.5rem; border-radius: 4px; font-size: 0.8rem; margin-left: 0.5rem; border: 1px solid rgba(255, 255, 255, 0.1); display: inline-block; }
        .command-inline { font-family: 'Courier New', Courier, monospace; background-color: rgba(2, 6, 23, 0.7); color: var(--primary-light); padding: 0.15em 0.5em; border-radius: 5px; font-size: 0.875em; border: 1px solid rgba(255, 255, 255, 0.08); display: inline-block; /* Changed */ vertical-align: middle; /* Changed */ word-break: break-word; margin: 0 0.1em; box-shadow: inset 1px 1px 3px rgba(0, 0, 0, 0.3); }
        .copy-command-btn { /* Style for the copy button */
            background: none; border: none; cursor: pointer; vertical-align: middle; /* Align with inline code */
            line-height: 1; /* Prevent extra height */
            color: var(--neutral); /* Explicit color */
            padding: 0.25rem; /* Add some clickable area */
            border-radius: 4px;
        }
        .copy-command-btn:hover { color: var(--primary-light); background-color: rgba(255, 255, 255, 0.1); }
        .copy-command-btn.text-secondary { color: var(--secondary) !important; }


        /* Loading */
        .loading-indicator { display: flex; justify-content: center; align-items: center; padding: 2rem; font-weight: 500; color: var(--neutral); } .loading-spinner { width: 24px; height: 24px; border: 3px solid rgba(139, 92, 246, 0.2); border-radius: 50%; border-top-color: var(--primary); animation: spin 1s linear infinite; margin-right: 10px; } @keyframes spin { to { transform: rotate(360deg); } }
        /* Error state for loading indicator */
        .loading-indicator.error { color: #f87171; /* Tailwind red-400 */ }
        .loading-indicator.error .loading-spinner { display: none; }

        /* Scroll Highlighting Fix */
        .protocol-card.highlighting {
            transition: box-shadow 0.3s ease-in-out !important; /* Override base transition specifically for highlight */
        }

        /* Mobile Responsiveness */
        @media (max-width: 640px) { .category-filter { padding: 0.3rem 0.8rem; font-size: 0.75rem; } .category-badge { font-size: 0.65rem; padding: 0.2rem 0.6rem; } .progress-container { height: 10px; } .card-header { padding: 1.2rem 1rem !important; } .card-header h2 { font-size: 1.5rem !important; } .protocol-card .grid { grid-template-columns: 1fr !important; display: block !important; } .glass-inset { margin-bottom: 1rem; } .toggle-container { min-width: 40px; width: 40px; height: 22px; } .toggle-slider:before { height: 14px; width: 14px; } .toggle-input:checked + .toggle-slider:before { transform: translateX(18px); } .nav-links { max-height: calc(100vh - 110px); } .list-item-no-checkbox { margin-left: 0.25rem; } .protocol-nav-item { padding-left: 0.75rem !important; padding-top: 0.75rem !important; padding-bottom: 0.75rem !important; padding-right: 0.75rem !important; } li.list-item-animate { padding: 0.75rem 0.5rem; margin-bottom: 0.75rem; } .pagination-btn { width: 36px; height: 36px; } .expand-btn { width: 36px; height: 36px; padding: 0.5rem !important; } /* Adjusted expand button size/padding */ .menu-toggle { width: 40px; height: 40px; padding: 0.5rem !important; } /* Adjusted menu toggle size/padding */ }
        @media (max-width: 768px) { .card-content { transition-duration: 0.4s; padding: 0 15px 0 15px; } .protocol-card.expanded .card-content { padding: 0 15px 15px 15px; } .content-section { transition-delay: 0.05s !important; } }

        /* Touch Device Hover Reset */
        @media (hover: none) and (pointer: coarse) { .glass-card:hover { transform: none; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2); } .category-filter:hover { transform: none; box-shadow: none; } .category-badge:hover::after, .card-header:hover .category-badge::after { animation: none; } .category-filter.active:hover::after { animation: none; } .expand-btn:hover { transform: none; box-shadow: none; } .expand-btn:hover::after { opacity: 0; } .pagination-btn:hover:not(:disabled) { transform: none; box-shadow: none; } .protocol-nav-item:hover { transform: none; box-shadow: none; background: rgba(15, 23, 42, 0.8) !important; } .no-results:hover { transform: none; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1); } li.list-item-animate:hover { transform: translateX(0) translateY(0); background: transparent; } }

    </style>
</head>
<body>
    <!-- Background Animation Elements REMOVED -->

    <!-- Mobile menu toggle -->
    <button id="menuToggle" class="fixed top-4 left-4 z-50 lg:hidden menu-toggle p-2 w-10 h-10 flex items-center justify-center glass-dark rounded-full text-white focus:outline-none">
        <i class="bx bx-menu text-2xl"></i>
    </button>

    <!-- Sidebar -->
    <aside class="sidebar glass-dark-effect" id="sidebar">
        <!-- Header -->
        <div class="flex flex-col mb-8 flex-shrink-0">
            <div class="flex items-center justify-between">
                <h1 class="text-2xl font-bold tracking-tight logo">
                    <span class="text-primary">Secure</span>Check
                </h1>
                <button id="mobileClose" class="lg:hidden p-1 rounded-full hover:bg-gray-700 focus:outline-none text-white">
                    <i class="bx bx-x text-2xl"></i>
                </button>
            </div>
             <div class="flex items-center mt-2">
                 <p class="text-xs text-gray-400 tracking-wide relative group">
                    <span class="text-primary">◈</span> Created by <span class="underline cursor-pointer text-gray-300 hover:text-primary transition-colors duration-300">Aditya Singh</span>
                    <span class="absolute bottom-full left-0 mb-2 w-48 p-2 bg-gray-800 rounded-md shadow-lg text-xs opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none z-10">
                        https://www.youtube.com/watch?v=dQw4w9WgXcQ<br>© 2025 All Rights Reserved
                    </span>
                </p>
            </div>
        </div>
        <!-- Search -->
        <div class="search-container flex-shrink-0">
            <input type="text" id="search" class="search-input" placeholder="Search protocols or ports...">
            <i class="bx bx-search search-icon"></i>
        </div>
        <!-- Protocols List -->
        <div class="protocol-section flex-grow flex flex-col min-h-0">
            <h2 class="text-lg font-semibold mb-2 text-neutral-300 flex-shrink-0">Protocols</h2>
            <div class="nav-links space-y-2" id="protocolNav">
                <!-- Protocol nav items rendered here -->
            </div>
        </div>
    </aside>

    <!-- Main content -->
    <main class="content-area" id="mainContent">
        <header class="mb-6 md:mb-10 fade-in" style="animation-delay: 0.1s;">
            <h1 class="text-3xl md:text-4xl font-bold mb-2">Protocol Security Checklist</h1>
            <p class="text-gray-400">Track testing procedures and discover vulnerabilities & tools for network protocols.</p>
        </header>

        <!-- Category Filters in Main Content -->
        <div id="mainCategoryFiltersContainer" class="mb-6 md:mb-8">
             <h2 class="text-lg font-semibold mb-3 text-neutral-300">Filter by Category:</h2>
             <div class="category-filters" id="categoryFilters">
                <button class="category-filter active" data-category="all">All</button>
                <!-- Category filters will be rendered here by JS -->
            </div>
        </div>

        <!-- Loading Indicator -->
        <div class="loading-indicator col-span-full" id="loadingIndicator" style="display: none;">
           <div class="loading-spinner"></div>
           <span class="loading-text">Loading protocols...</span>
       </div>

        <!-- Protocol Cards Grid -->
        <div class="grid grid-cols-1 gap-6" id="protocolCards">
            <!-- Protocol Cards will be rendered here -->
        </div>

        <!-- Pagination -->
        <div class="pagination-container" id="paginationContainer">
             <!-- Pagination will be rendered here -->
        </div>
    </main>

    <script>
        // --- DATA SOURCE ---
        const DATA_URL = 'https://raw.githubusercontent.com/adityasingh1996/SecureCheck/refs/heads/main/Data';

        // --- GLOBAL DATA STORE ---
        let protocolData = []; // Initialize as empty, will be filled by fetch

        // --- STATE ---
        const appState = {
            currentFilter: 'all',
            searchTerm: '',
            checkedItems: {},
            currentPage: 1,
            itemsPerPage: 5,
            debug: true, // Set true for console logs
            expandedCards: new Set(),
            isMobile: false,
            observer: null
        };

        // --- UTILITIES ---
        function debug(message) { if (appState.debug) console.log(`[DEBUG] ${message}`); }
        const debounce = (func, delay) => { let timeout; return (...args) => { const context = this; clearTimeout(timeout); timeout = setTimeout(() => func.apply(context, args), delay); }; };

        // --- DATA FETCHING & PARSING (Simplified for Valid JSON) ---
        async function fetchProtocolData() {
            debug(`Fetching data from ${DATA_URL}...`);
            const loadingIndicator = document.getElementById('loadingIndicator');
            const loadingText = loadingIndicator?.querySelector('.loading-text');

            if (loadingIndicator) {
                loadingIndicator.classList.remove('error');
                if (loadingText) loadingText.textContent = 'Loading protocols...';
                loadingIndicator.style.display = 'flex';
            }

            try {
                const response = await fetch(DATA_URL);

                // Check for HTTP errors (like 404 Not Found, 500 Server Error)
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status} ${response.statusText}`);
                }

                // Directly parse the response body as JSON
                const parsedData = await response.json();
                debug(`Data parsed successfully via response.json(). ${parsedData?.length || 0} protocols loaded.`);

                // Optional: Basic validation (check if it's an array)
                if (!Array.isArray(parsedData)) {
                    throw new TypeError("Fetched data is not an array.");
                }

                if (loadingIndicator) loadingIndicator.style.display = 'none'; // Hide on success
                return parsedData;

            } catch (error) {
                console.error("Error fetching or parsing protocol data:", error);

                // Log the specific error
                if (loadingIndicator) {
                    loadingIndicator.style.display = 'flex';
                    loadingIndicator.classList.add('error');
                    if (loadingText) {
                        // Provide a slightly more specific error message based on the error type
                        let errorMsg = "Failed to load protocol data. Check console logs.";
                        if (error instanceof SyntaxError) {
                            errorMsg = "Failed to parse protocol data (Invalid JSON format). Check console.";
                        } else if (error instanceof TypeError) {
                             errorMsg = "Fetched data has unexpected format (not an array). Check console.";
                        } else if (error.message.startsWith("HTTP error")) {
                             errorMsg = `Failed to fetch protocol data (${error.message}). Check network tab/console.`;
                        }
                         loadingText.innerHTML = `<i class='bx bx-error-circle mr-2'></i> ${errorMsg}`;
                    }
                }
                return null; // Indicate failure
            }
        }


        // --- INITIALIZATION ---
        document.addEventListener('DOMContentLoaded', async () => { // Make the listener async
            debug('App initializing...');
            const requiredElements = [
                'loadingIndicator', 'protocolCards', 'paginationContainer',
                'protocolNav', 'sidebar', 'categoryFilters'
            ];
            let missingElement = false;
            for (const id of requiredElements) {
                 if (!document.getElementById(id)) {
                     console.error(`Initialization failed: Required DOM element #${id} not found.`);
                     missingElement = true;
                 }
            }
             if (missingElement) {
                 const body = document.body || document.createElement('body');
                 body.innerHTML = `<div style="color: red; padding: 20px; font-family: sans-serif; text-align: center;">Error: Core UI elements missing. Cannot initialize application.</div>`;
                 return;
             }

            // --- Fetch data FIRST ---
            const fetchedData = await fetchProtocolData();

            if (fetchedData === null || !Array.isArray(fetchedData)) {
                // Error already shown by fetchProtocolData, just stop initialization
                debug("Initialization stopped due to data fetch failure.");
                return;
            }

            // --- Assign fetched data ---
            protocolData = fetchedData; // Assign to the global variable
             debug(`Assigned fetched data (${protocolData.length} items) to global scope.`);

            // --- Proceed with initialization using the fetched data ---
            try {
                updateDeviceState();
                loadCheckedItems();
                renderSidebarProtocols(); // Now uses the fetched data
                initializeMainCategoryFilters(); // Now uses the fetched data
                setupEventListeners();
                initializeAnimations();
                renderProtocolCards(); // Now uses the fetched data
                setTimeout(updateProgress, 300); // Needs data loaded first
                debug('App initialized successfully.');
             } catch (error) {
                 console.error("Error during initialization steps after data fetch:", error);
                 const loadingIndicator = document.getElementById('loadingIndicator');
                 if (loadingIndicator) {
                      const loadingText = loadingIndicator.querySelector('.loading-text');
                      loadingIndicator.style.display = 'flex';
                      loadingIndicator.classList.add('error');
                      if (loadingText) loadingText.innerHTML = `<i class='bx bx-error-circle text-2xl text-red-500 mr-2'></i> Error initializing application after loading data. Check console.`;
                 }
             }
        });


        // --- CORE LOGIC (Functions remain largely the same, but now rely on the globally scoped `protocolData` which is populated by fetch) ---

        function updateDeviceState() {
             const wasMobile = appState.isMobile;
            appState.isMobile = window.innerWidth < 768;
            if (appState.isMobile) { appState.itemsPerPage = 3; }
            else if (window.innerWidth < 1280) { appState.itemsPerPage = 4; }
            else { appState.itemsPerPage = 5; }
            debug(`Device state: isMobile=${appState.isMobile}, itemsPerPage=${appState.itemsPerPage}`);
             // Only re-render if initialization is complete and state changed
             if (document.readyState === 'complete' && protocolData.length > 0 && wasMobile !== appState.isMobile) {
                 renderProtocolCards();
                 renderSidebarProtocols();
            }
         }

        function loadCheckedItems() {
             try {
                const saved = localStorage.getItem('checkedItems');
                if (saved) { appState.checkedItems = JSON.parse(saved); }
                const testingKeys = Object.keys(appState.checkedItems).filter(key => key.includes('-testing-'));
                debug(`Loaded ${testingKeys.length} checked testing items`);
             } catch (e) { console.error("Error loading checked items:", e); appState.checkedItems = {}; }
         }

        function getPortDisplay(port) {
             if (port === null || typeof port === 'undefined') return '';
             const portStr = String(port); if (!portStr) return '';
             if (portStr.includes(',') || portStr.includes('-') || portStr.includes(' ')) { return `<span class="port-badge">Ports ${portStr}</span>`; }
             else if (/\d+/.test(portStr)) { return `<span class="port-badge">Port ${portStr}</span>`; }
             return '';
         }

        function renderSidebarProtocols() {
            debug('Rendering sidebar protocol list...');
            const protocolNav = document.getElementById('protocolNav');
            if (!protocolNav) { console.error("Sidebar render failed: #protocolNav not found."); return; }

            // Ensure protocolData is available
            if (!protocolData || protocolData.length === 0) {
                protocolNav.innerHTML = '<p class="text-sm text-neutral-500 px-3">No protocols loaded.</p>';
                debug('Sidebar render skipped: No protocol data available.');
                return;
            }

            const fragment = document.createDocumentFragment();
            const filteredProtocols = getFilteredProtocols(); // Uses global protocolData

            if (filteredProtocols.length === 0) {
                protocolNav.innerHTML = '<p class="text-sm text-neutral-500 px-3">No matching protocols.</p>';
                return;
            }

            const sortedProtocols = [...filteredProtocols].sort((a, b) => (a.name || '').localeCompare(b.name || ''));
             sortedProtocols.forEach((protocol, index) => {
                 if (!protocol || !protocol.id) return;
                 const navItem = document.createElement('div');
                 navItem.className = 'glass-inset py-3 pr-3 cursor-pointer transition-all duration-300 protocol-nav-item fade-in';
                 navItem.setAttribute('data-protocol-id', protocol.id);
                 navItem.setAttribute('data-category', protocol.category || 'default');
                 navItem.style.animationDelay = `${index * 0.03}s`;
                 const categoryColor = getCategoryColor(protocol.category); // Get color object
                 navItem.style.setProperty('--nav-item-color', categoryColor.background); // Use background property
                 navItem.innerHTML = `<div class="flex items-center justify-between text-sm"><div class="flex items-center overflow-hidden whitespace-nowrap text-ellipsis"><i class="bx bx-chevron-right mr-1 text-primary flex-shrink-0"></i><span class="overflow-hidden whitespace-nowrap text-ellipsis">${protocol.name || 'Unnamed'}</span></div></div>`;
                 fragment.appendChild(navItem);
            });

            protocolNav.innerHTML = ''; // Clear previous content
            protocolNav.appendChild(fragment);
            debug(`Sidebar rendered ${sortedProtocols.length} items.`);
        }

        function initializeMainCategoryFilters() {
            debug('Initializing main category filters...');
            const categoryFilters = document.getElementById('categoryFilters');
            if (!categoryFilters) { console.error("Category filter init failed: #categoryFilters not found."); return; }

             // Ensure protocolData is available
            if (!protocolData || protocolData.length === 0) {
                debug('Category filter init skipped: No protocol data available.');
                // Keep the 'All' button, but don't add others
                let allCategoryBtn = categoryFilters.querySelector('[data-category="all"]');
                if (!allCategoryBtn) {
                     allCategoryBtn = document.createElement('button');
                     allCategoryBtn.className = 'category-filter active';
                     allCategoryBtn.setAttribute('data-category', 'all');
                     allCategoryBtn.textContent = 'All';
                     categoryFilters.appendChild(allCategoryBtn); // Use appendChild if it's the only one
                 } else {
                    // Remove any dynamically added category buttons from previous runs if data failed now
                    const existingFilters = categoryFilters.querySelectorAll('.category-filter:not([data-category="all"])');
                    existingFilters.forEach(btn => btn.remove());
                     allCategoryBtn.classList.add('active'); // Ensure 'All' is active
                 }
                if(allCategoryBtn) allCategoryBtn.style.setProperty('--active-filter-bg', 'var(--primary)'); // Set 'All' button color
                 return;
            }

             const categories = [...new Set(protocolData.map(p => p.category || 'default'))].sort();

             let allCategoryBtn = categoryFilters.querySelector('[data-category="all"]');
             if (!allCategoryBtn) {
                 console.warn("'All' button missing, creating it.");
                 allCategoryBtn = document.createElement('button');
                 allCategoryBtn.className = 'category-filter active';
                 allCategoryBtn.setAttribute('data-category', 'all');
                 allCategoryBtn.textContent = 'All';
                 categoryFilters.insertBefore(allCategoryBtn, categoryFilters.firstChild);
             } else {
                 // Clear previously added dynamic filters before adding new ones
                 const existingFilters = categoryFilters.querySelectorAll('.category-filter:not([data-category="all"])');
                 existingFilters.forEach(btn => btn.remove());
                 allCategoryBtn.classList.add('active'); // Ensure 'All' is active
             }
             allCategoryBtn.style.setProperty('--active-filter-bg', 'var(--primary)'); // Set 'All' button color

             categories.forEach(category => {
                 const categoryBtn = document.createElement('button');
                 categoryBtn.className = 'category-filter';
                 categoryBtn.setAttribute('data-category', category);
                 categoryBtn.textContent = category.charAt(0).toUpperCase() + category.slice(1);
                 categoryFilters.appendChild(categoryBtn);
             });
             debug(`Main category filters initialized with ${categories.length} categories.`);
        }

        function getFilteredProtocols() {
             // Ensure protocolData is available before filtering
             if (!protocolData || protocolData.length === 0) {
                 return [];
             }
             try {
                 const lowerSearchTerm = appState.searchTerm.toLowerCase();
                 return protocolData.filter(protocol => {
                     if (!protocol || !protocol.name || !protocol.description) { return false; }
                     const currentCategory = appState.currentFilter === 'all' ? null : appState.currentFilter;
                     const protocolCategory = protocol.category || 'default';
                     const matchesCategory = !currentCategory || protocolCategory === currentCategory;
                     const matchesSearch = !lowerSearchTerm ||
                        protocol.name.toLowerCase().includes(lowerSearchTerm) ||
                        protocol.description.toLowerCase().includes(lowerSearchTerm) ||
                        (protocol.port != null && String(protocol.port).toLowerCase().includes(lowerSearchTerm)) || // Simplified port check
                        matchesPort(protocol.port, lowerSearchTerm); // Keep specific port logic too
                     return matchesCategory && matchesSearch;
                 });
             } catch (error) {
                 console.error("Error filtering protocol data:", error);
                 return [];
             }
         }

         function matchesPort(protocolPort, searchTerm) {
             if (protocolPort === null || typeof protocolPort === 'undefined' || !searchTerm) return false;
             const portStr = String(protocolPort).toLowerCase();
             const searchStr = String(searchTerm).toLowerCase().trim();
             if (!portStr || !searchStr || !/\d/.test(searchStr)) return false; // Ignore search if not number-like

             const searchPorts = searchStr.split(',').map(p => p.trim()).filter(p => p !== '');
             if (searchPorts.length === 0) return false;

             // Direct match first
             if (searchPorts.includes(portStr)) return true;

             for (const singleSearchPort of searchPorts) {
                 // Check if search term is within a comma-separated list in protocolPort
                 if (portStr.includes(',')) {
                     const protocolPortList = portStr.split(',').map(p => p.trim());
                     if (protocolPortList.includes(singleSearchPort)) return true;
                 }
                 // Check if search term is within a range in protocolPort (e.g., protocolPort="10-20", singleSearchPort="15")
                 if (portStr.includes('-') && !portStr.includes(',')) { // Avoid parsing comma-lists as ranges
                     const [minPort, maxPort] = portStr.split('-').map(p => parseInt(p.trim(), 10));
                     if (!isNaN(minPort) && !isNaN(maxPort)) {
                         const searchNum = parseInt(singleSearchPort, 10);
                         if (!isNaN(searchNum) && searchNum >= minPort && searchNum <= maxPort) return true;
                     }
                 }
                  // Check if protocolPort is within a range specified in search (e.g., protocolPort="80", singleSearchPort="70-90")
                 if (singleSearchPort.includes('-')) {
                     const [minSearch, maxSearch] = singleSearchPort.split('-').map(p => parseInt(p.trim(), 10));
                     if (!isNaN(minSearch) && !isNaN(maxSearch)) {
                         const protocolPortNum = parseInt(portStr, 10); // Assuming single port number here
                         if (!isNaN(protocolPortNum) && protocolPortNum >= minSearch && protocolPortNum <= maxSearch) return true;
                     }
                 }
             }
             return false;
        }

        function renderProtocolCards() {
            const container = document.getElementById('protocolCards');
            const pagination = document.getElementById('paginationContainer');
            const loadingIndicator = document.getElementById('loadingIndicator'); // Refetch in case it was changed

            if (!container || !pagination) {
                console.error("Render failed: #protocolCards or #paginationContainer missing.");
                if (loadingIndicator) loadingIndicator.style.display = 'none'; // Hide loading if render fails
                return;
            }

            const currentPageForRender = appState.currentPage;
            const currentFilterForRender = appState.currentFilter;
            const currentSearchForRender = appState.searchTerm;
            debug(`Render Cards: Filter="${currentFilterForRender}", Search="${currentSearchForRender}", Page=${currentPageForRender}`);

            container.innerHTML = ''; // Clear previous cards
            pagination.style.display = 'none'; // Hide pagination until calculated

             // Use requestAnimationFrame for smoother UI updates
            requestAnimationFrame(() => {
                try {
                    // Disconnect observer before re-rendering
                    if (appState.observer) appState.observer.disconnect();

                    const fragment = document.createDocumentFragment();
                    const filtered = getFilteredProtocols(); // Uses global protocolData

                    if (filtered.length === 0) {
                        // Check if data failed to load vs. just no matching filters
                        if (protocolData === null || protocolData.length === 0) {
                            // Error message handled by fetch failure, keep container empty or show specific message if needed
                             if (!document.querySelector('.loading-indicator.error')) { // Avoid duplicating error
                                container.innerHTML = `<div class="no-results section-animate visible col-span-full"><i class='bx bx-data text-4xl mb-2 text-gray-500'></i><h3 class="text-xl font-semibold mb-2">No Protocol Data</h3><p class="text-gray-400">Could not load protocol information.</p></div>`;
                                requestAnimationFrame(() => container.querySelector('.no-results')?.classList.add('visible'));
                            }
                        } else {
                            // No results matching filters/search
                            container.innerHTML = `<div class="no-results section-animate visible col-span-full"><i class="bx bx-search text-4xl mb-2 text-gray-500"></i><h3 class="text-xl font-semibold mb-2">No protocols found</h3><p class="text-gray-400">Try adjusting search or category.</p></div>`;
                            requestAnimationFrame(() => container.querySelector('.no-results')?.classList.add('visible'));
                        }
                         pagination.style.display = 'none';
                         debug('Render complete: No results.');
                    } else {
                        // Paginate results
                        const totalPages = Math.ceil(filtered.length / appState.itemsPerPage);
                        let validatedPage = Math.max(1, Math.min(currentPageForRender, totalPages));

                         if (validatedPage !== currentPageForRender) {
                            debug(`Page validated: ${currentPageForRender} -> ${validatedPage}`);
                             // Crucially, update the global state if validation changes the page
                             if(appState.currentPage !== validatedPage) {
                                appState.currentPage = validatedPage;
                                debug(`Global page updated to ${validatedPage} during render`);
                            }
                        }

                        debug(`Render SLICING: Page ${validatedPage} of ${totalPages}`);
                        const start = (validatedPage - 1) * appState.itemsPerPage;
                        const end = Math.min(start + appState.itemsPerPage, filtered.length);
                        debug(`Slice: ${start}-${end} of ${filtered.length}`);
                        const toRender = filtered.slice(start, end);

                        if (toRender.length === 0 && filtered.length > 0 && validatedPage > 1) {
                             console.warn(`Pagination Error: Empty slice on page ${validatedPage}. Resetting to page 1.`);
                             // Attempt recovery by going to page 1
                             appState.currentPage = 1;
                             renderProtocolCards(); // Re-render on page 1
                             return; // Stop current render pass
                         } else if (toRender.length === 0 && filtered.length > 0) {
                             console.warn(`Pagination Error: Empty slice on page ${validatedPage} with total items ${filtered.length}.`);
                            container.innerHTML = `<div class="no-results section-animate visible col-span-full"><i class='bx bx-error text-4xl text-yellow-500 mb-2'></i><h3 class="text-xl font-semibold mb-2 text-yellow-400">Pagination Error</h3></div>`;
                         } else {
                            // Render the cards for the current page
                            toRender.forEach((protocol, index) => {
                                const card = createProtocolCard(protocol, index);
                                if (card) {
                                    fragment.appendChild(card);
                                    // Re-initialize observer for new cards
                                    if (appState.observer) appState.observer.observe(card);
                                }
                            });
                            container.appendChild(fragment);
                            updatePagination(totalPages); // Update pagination controls
                        }

                        updateProgress(); // Update progress bars for visible cards
                        requestAnimationFrame(handleScrollAnimations); // Trigger animations for newly added cards
                        debug('Render complete: Cards rendered.');
                    }
                } catch (error) {
                    console.error("Error during card rendering phase:", error);
                    container.innerHTML = `<div class="no-results section-animate visible col-span-full"><i class='bx bx-error-circle text-4xl text-red-500 mb-2'></i><h3>Error Rendering Cards</h3><p class="text-gray-400">Check console for details.</p></div>`;
                    pagination.style.display = 'none';
                } finally {
                     // Ensure loading indicator is hidden unless there was a fetch error shown
                     if (loadingIndicator && !loadingIndicator.classList.contains('error')) {
                        loadingIndicator.style.display = 'none';
                    }
                    debug("Render Card UI update finished.");
                }
             });
        }

        function updatePagination(totalPages) {
             const container = document.getElementById('paginationContainer');
             if (!container) return;
             container.innerHTML = ''; // Clear previous pagination

             if (totalPages <= 1) {
                 container.style.display = 'none';
                 return;
             }
             container.style.display = 'flex'; // Show pagination container

             const currentPage = appState.currentPage; // Use current state

             // Previous Button
             const prevBtn = document.createElement('button');
             prevBtn.className = 'pagination-btn';
             prevBtn.innerHTML = '<i class="bx bx-chevron-left pointer-events-none"></i>';
             prevBtn.disabled = currentPage === 1;
             prevBtn.setAttribute('aria-label', 'Previous page');
             prevBtn.addEventListener('click', () => goToPage(currentPage - 1));
             container.appendChild(prevBtn);

             // Page Number Buttons (with Ellipsis logic)
             const maxVisible = appState.isMobile ? 3 : 5; // Max page numbers shown
             let startPage = Math.max(1, currentPage - Math.floor(maxVisible / 2));
             let endPage = Math.min(totalPages, startPage + maxVisible - 1);

             // Adjust startPage if endPage reaches the limit too early
             if (endPage - startPage + 1 < maxVisible) {
                 startPage = Math.max(1, endPage - maxVisible + 1);
             }

             // Ellipsis and '1' at the beginning
             if (startPage > 1) {
                 const firstBtn = document.createElement('button');
                 firstBtn.className = 'pagination-btn';
                 firstBtn.textContent = '1';
                 firstBtn.setAttribute('aria-label', 'Page 1');
                 firstBtn.addEventListener('click', () => goToPage(1));
                 container.appendChild(firstBtn);
                 if (startPage > 2) {
                     const ellipsis = document.createElement('span');
                     ellipsis.className = 'pagination-ellipsis';
                     ellipsis.textContent = '...';
                     ellipsis.setAttribute('aria-hidden', 'true');
                     container.appendChild(ellipsis);
                 }
             }

             // Visible page numbers
             for (let i = startPage; i <= endPage; i++) {
                 const pageBtn = document.createElement('button');
                 pageBtn.className = `pagination-btn ${i === currentPage ? 'active' : ''}`;
                 pageBtn.textContent = i;
                 pageBtn.setAttribute('aria-label', `Page ${i}`);
                 if (i === currentPage) pageBtn.setAttribute('aria-current', 'page');
                 pageBtn.addEventListener('click', () => goToPage(i));
                 container.appendChild(pageBtn);
             }

             // Ellipsis and Last page at the end
             if (endPage < totalPages) {
                 if (endPage < totalPages - 1) {
                     const ellipsis = document.createElement('span');
                     ellipsis.className = 'pagination-ellipsis';
                     ellipsis.textContent = '...';
                     ellipsis.setAttribute('aria-hidden', 'true');
                     container.appendChild(ellipsis);
                 }
                 const lastBtn = document.createElement('button');
                 lastBtn.className = 'pagination-btn';
                 lastBtn.textContent = totalPages;
                 lastBtn.setAttribute('aria-label', `Page ${totalPages}`);
                 lastBtn.addEventListener('click', () => goToPage(totalPages));
                 container.appendChild(lastBtn);
             }

             // Next Button
             const nextBtn = document.createElement('button');
             nextBtn.className = 'pagination-btn';
             nextBtn.innerHTML = '<i class="bx bx-chevron-right pointer-events-none"></i>';
             nextBtn.disabled = currentPage === totalPages;
             nextBtn.setAttribute('aria-label', 'Next page');
             nextBtn.addEventListener('click', () => goToPage(currentPage + 1));
             container.appendChild(nextBtn);
             debug(`Pagination updated: page ${currentPage} of ${totalPages}`);
         }


        function goToPage(page) {
            debug(`goToPage called: req=${page}, current=${appState.currentPage}`);
            if (page === appState.currentPage || page < 1) return; // Ignore if same page or invalid request

             // Recalculate total pages based on current filters *before* navigating
             const filtered = getFilteredProtocols();
             const totalPages = Math.ceil(filtered.length / appState.itemsPerPage);

             // Clamp page number to valid range
             const targetPage = Math.max(1, Math.min(page, totalPages));

             if (targetPage === appState.currentPage) {
                 debug("goToPage: Target page is same as current after validation.");
                 return; // Ignore if validation results in current page
             }

            appState.currentPage = targetPage; // Update state *before* rendering
            debug(`appState.currentPage updated: ${appState.currentPage}`);

             // Re-render cards for the new page
             renderProtocolCards();

             // Scroll to top of content area after page change
             const mainContent = document.getElementById('mainContent');
             if (mainContent) {
                 // Small delay to allow render to start, then scroll
                 setTimeout(() => {
                    mainContent.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }, 50);
            } else {
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }
        }

        function generateListItems(items, type, protocolId) {
             if (!items || items.length === 0) return '<li class="text-gray-500 text-sm list-item-no-checkbox">None listed.</li>';

            const includeCheckbox = (type === 'testing');

            const copyButtonHtml = `
                <button class="copy-command-btn ml-2 p-1 text-neutral-400 hover:text-primary focus:outline-none focus:ring-1 focus:ring-primary-light rounded transition-colors duration-200 inline-flex items-center align-middle"
                        title="Copy command"
                        aria-label="Copy command to clipboard">
                    <i class='bx bx-copy text-sm pointer-events-none'></i>
                </button>`;

            return items.map((item, i) => {
                 if (typeof item !== 'string' || item.trim() === '') return ''; // Skip empty items
                const key = `${protocolId}-${type}-${i}`;
                const isChecked = includeCheckbox && appState.checkedItems[key];

                // Process `<code>` tags and add copy button
                const processedItem = item.replace(/`([^`]+)`/g, (match, codeContent) => {
                    const escapedCode = codeContent.replace(/</g, "&lt;").replace(/>/g, "&gt;"); // Basic escaping
                    const codeTag = `<code class="command-inline">${escapedCode}</code>`;
                    // Add copy button only next to code blocks in 'testing' section
                    return (type === 'testing') ? codeTag + copyButtonHtml : codeTag;
                });

                let listItemHTML = `<li class="flex items-start list-item-animate ${!includeCheckbox ? 'list-item-no-checkbox-container' : ''} mb-1">`; // Added margin-bottom
                if (includeCheckbox) {
                     listItemHTML += `
                        <label class="toggle-container inline-flex mr-3 mt-0.5 flex-shrink-0">
                            <input type="checkbox" class="toggle-input ${type}-check" data-protocol="${protocolId}" data-type="${type}" data-index="${i}" ${isChecked ? 'checked' : ''}>
                            <span class="toggle-slider"></span>
                        </label>
                        <span class="checkmark-animate text-sm flex-grow ${isChecked ? 'line-through text-gray-500' : ''}">${processedItem}</span>`;
                } else {
                     // For non-checkbox lists, ensure the icon/bullet aligns better if needed, or just display text
                     listItemHTML += `<span class="text-sm flex-grow list-item-no-checkbox">${processedItem}</span>`;
                 }
                 listItemHTML += `</li>`;
                 return listItemHTML;
             }).join('');
         }

        // --- MODIFIED: createProtocolCard (Layout remains the same, logic uses global protocolData, uses categoryColor.background) ---
        function createProtocolCard(protocol, indexOnPage) {
             try {
                 if (!protocol || !protocol.id || !protocol.name) { console.warn("Skipping card: invalid data:", protocol); return null; }
                 const card = document.createElement('div'); card.className = 'protocol-card glass-card section-animate relative'; card.id = protocol.id;
                 const categoryColor = getCategoryColor(protocol.category); // Get color object
                 const totalItems = protocol.testing?.length || 0; let checkedCount = 0;
                 if (protocol.testing) { protocol.testing.forEach((_, i) => { if (appState.checkedItems[`${protocol.id}-testing-${i}`]) { checkedCount++; } }); }
                 const percentage = totalItems > 0 ? Math.round((checkedCount / totalItems) * 100) : 0; let portDisplayHtml = getPortDisplay(protocol.port); const isExpanded = appState.expandedCards.has(protocol.id);
                 const vulnerabilitiesList = generateListItems(protocol.vulnerabilities, 'vulnerability', protocol.id); const testingList = generateListItems(protocol.testing, 'testing', protocol.id); const toolsList = generateListItems(protocol.tools, 'tool', protocol.id);

                 // Card Header remains the same structure
                 card.innerHTML = `
                    <div class="category-indicator" style="background: ${categoryColor.background}"></div> 
                    <div class="card-header p-4 md:p-6 flex flex-col md:flex-row md:items-center justify-between" data-id="${protocol.id}">
                        <div class="flex-grow mb-3 md:mb-0 md:mr-4">
                            <div class="flex items-center mb-1 flex-wrap">
                                <h2 class="text-xl md:text-2xl font-bold mr-3">${protocol.name}</h2>
                                ${portDisplayHtml}
                                <span class="category-badge ml-3 mt-1 md:mt-0" style="background: ${categoryColor.background};">${protocol.category || 'other'}</span> 
                            </div>
                            <p class="text-gray-400 text-sm">${protocol.description || ''}</p>
                        </div>
                        <div class="flex items-center justify-between md:justify-start flex-shrink-0 w-full md:w-auto">
                             <div class="mr-4 relative text-center md:text-left flex-grow md:flex-grow-0">
                                <div class="text-xs text-gray-400 mb-1">Testing Progress</div>
                                <div class="progress-container w-full md:w-32">
                                    <div class="progress-bar" data-protocol="${protocol.id}" style="width: ${percentage}%"></div>
                                    <div class="completion-percentage">${percentage}%</div>
                                </div>
                            </div>
                            <button class="expand-btn bg-gray-800 hover:bg-gray-700 w-9 h-9 flex items-center justify-center rounded-full transition-all duration-300 flex-shrink-0" aria-expanded="${isExpanded}">
                                <i class="bx bx-chevron-down text-2xl transition-transform duration-300 ${isExpanded ? 'transform rotate-180' : ''}"></i>
                            </button>
                        </div>
                    </div>
                    `;

                 // Card Content with NEW layout
                 card.innerHTML += `
                    <div class="card-content">
                        <div class="grid grid-cols-1 lg:grid-cols-3 gap-4 md:gap-6 pt-2 md:pt-4">
                            <div class="glass-inset p-4 content-section lg:col-span-1">
                                <h3 class="text-base md:text-lg font-semibold mb-3 flex items-center"><i class="bx bx-shield-quarter text-red-500 mr-2"></i> Vulnerabilities</h3>
                                <ul class="space-y-2">${vulnerabilitiesList}</ul>
                            </div>
                            <div class="glass-inset p-4 content-section lg:col-span-2">
                                <h3 class="text-base md:text-lg font-semibold mb-3 flex items-center"><i class="bx bx-test-tube text-yellow-500 mr-2"></i> Testing</h3>
                                <ul class="space-y-2">${testingList}</ul>
                            </div>
                            <div class="glass-inset p-4 content-section lg:col-span-3">
                                <h3 class="text-base md:text-lg font-semibold mb-3 flex items-center"><i class="bx bx-wrench text-blue-500 mr-2"></i> Tools</h3>
                                <ul class="space-y-2">${toolsList}</ul>
                            </div>
                        </div>
                    </div>`;


                 // Restore expanded state if applicable (no change here)
                 if (isExpanded) {
                     card.classList.add('expanded');
                     const content = card.querySelector('.card-content');
                     if (content) {
                         // Apply expanded styles without animation initially
                         content.style.transition = 'none'; // Disable transition for initial setup
                         content.style.maxHeight = '2000px'; // Set max-height directly
                         content.style.opacity = '1';
                         content.style.visibility = 'visible';
                         content.style.transform = 'translateY(0)';
                         content.style.paddingTop = '1rem'; // Match expanded padding
                         content.style.paddingBottom = '20px';

                         // Make content sections visible immediately too
                         card.querySelectorAll('.content-section, .list-item-animate').forEach(el => {
                             el.style.transition = 'none'; // Disable transition for initial setup
                             el.style.opacity = '1';
                             el.style.transform = 'translate(0, 0)';
                              // Restore transition after a frame
                             requestAnimationFrame(() => { el.style.transition = ''; });
                         });
                          // Restore transition after a frame
                         requestAnimationFrame(() => { content.style.transition = ''; });
                     }
                 }
                 return card;
             } catch (error) { console.error(`Error creating card for ${protocol?.id}:`, error); return null; }
          }
        // --- END MODIFIED ---

        function filterByCategory(category) {
            debug(`Filtering category: "${category}"`);
            if (appState.currentFilter === category) return;

            appState.currentFilter = category;
            appState.currentPage = 1; // Reset to page 1 on filter change

            document.querySelectorAll('#categoryFilters .category-filter').forEach(btn => {
                const btnCategory = btn.getAttribute('data-category');
                const isActive = (btnCategory === category);
                btn.classList.toggle('active', isActive);
                if (isActive) {
                    // Get the appropriate color for the active filter button
                    const activeColor = (category === 'all')
                        ? 'var(--primary)' // Use primary for 'All'
                        : getCategoryColor(category).background; // Use category background gradient
                    btn.style.setProperty('--active-filter-bg', activeColor);
                    debug(`Set active color for filter '${category}': ${activeColor}`);
                } else {
                    btn.style.removeProperty('--active-filter-bg'); // Remove style if not active
                }
            });

             // Re-render cards and sidebar with the new filter
            renderProtocolCards();
            renderSidebarProtocols();
        }

        function setupEventListeners() {
            debug('Setting up listeners...');
            const sidebar = document.getElementById('sidebar');
            const mainContent = document.getElementById('mainContent');
            const categoryFilters = document.getElementById('categoryFilters');
            const protocolCardsContainer = document.getElementById('protocolCards');
            const protocolNavContainer = document.getElementById('protocolNav');
            const searchInput = document.getElementById('search');
            const menuToggle = document.getElementById('menuToggle');
            const mobileClose = document.getElementById('mobileClose');

            // --- Basic Listeners ---
            menuToggle?.addEventListener('click', () => sidebar?.classList.add('open'));
            mobileClose?.addEventListener('click', () => sidebar?.classList.remove('open'));

             // Close sidebar on click outside on mobile
             document.body.addEventListener('click', (e) => {
                if (appState.isMobile && sidebar?.classList.contains('open')) {
                    // Check if the click is outside the sidebar and not on the toggle button
                     if (!sidebar.contains(e.target) && !menuToggle?.contains(e.target)) {
                        sidebar.classList.remove('open');
                    }
                }
             }, true); // Use capture phase to catch clicks early

             searchInput?.addEventListener('input', debounce((e) => {
                appState.searchTerm = e.target.value.trim();
                appState.currentPage = 1; // Reset page on search
                renderProtocolCards();
                renderSidebarProtocols();
            }, 300));
            // --- End Basic Listeners ---


            // --- Combined Click Listener for #protocolCards (Expansion & Copy) ---
             protocolCardsContainer?.addEventListener('click', (e) => {
                 // Card Expansion Logic - Triggered by header or expand button
                 const trigger = e.target.closest('.card-header, .expand-btn');
                 // Ensure the click wasn't on an *interactive* element inside the header EXCEPT the expand button itself
                 const isInteractiveClick = e.target.closest('a, button:not(.expand-btn), input, label');

                 if (trigger && !isInteractiveClick) {
                    const card = trigger.closest('.protocol-card');
                    if (card) {
                        toggleCardExpansion(card); // Handles expansion AND post-expansion scroll
                        return; // Expansion handled, stop processing
                    }
                }

                // Copy Command Logic
                const copyButton = e.target.closest('.copy-command-btn');
                if (copyButton) {
                     // Find the preceding <code> element
                     const codeElement = copyButton.previousElementSibling;
                     if (codeElement && codeElement.tagName === 'CODE' && codeElement.classList.contains('command-inline')) {
                         const commandText = codeElement.textContent || '';
                         if (commandText) {
                            navigator.clipboard.writeText(commandText).then(() => {
                                debug(`Copied: ${commandText}`);
                                const icon = copyButton.querySelector('i');
                                if (icon) {
                                    const originalIcon = icon.className;
                                     copyButton.classList.add('text-secondary'); // Use secondary color for success
                                     icon.className = 'bx bx-check text-sm pointer-events-none';
                                     copyButton.disabled = true; // Briefly disable
                                     setTimeout(() => {
                                         copyButton.classList.remove('text-secondary');
                                         icon.className = originalIcon;
                                         copyButton.disabled = false;
                                     }, 1500);
                                }
                             }).catch(err => {
                                console.error('Failed to copy command: ', err);
                                // Optional: Provide visual feedback for copy failure
                             });
                         }
                    } else {
                        console.warn('Could not find command code element next to copy button.', copyButton);
                    }
                    return; // Copy handled, stop processing
                }
             }); // End click listener for cards container

            // --- Separate Change Listener for Checkboxes inside #protocolCards ---
             protocolCardsContainer?.addEventListener('change', (e) => {
                if (e.target.classList.contains('toggle-input') && e.target.type === 'checkbox') {
                    handleCheckboxChange(e.target);
                }
            });

            // --- Category Filter Listener ---
             categoryFilters?.addEventListener('click', (e) => {
                 const btn = e.target.closest('.category-filter');
                 // Only trigger filter if the button exists and is not already active
                 if (btn && !btn.classList.contains('active')) {
                     const category = btn.getAttribute('data-category');
                     if (category) {
                        filterByCategory(category);
                    }
                }
            });

            // --- Sidebar Navigation Listener ---
             protocolNavContainer?.addEventListener('click', (e) => {
                 const item = e.target.closest('[data-protocol-id]');
                 if (item) {
                     const id = item.getAttribute('data-protocol-id');
                     if (id) {
                        scrollToProtocol(id); // Handles finding page, scrolling, highlighting, and expanding
                         // Close sidebar on mobile after clicking a nav item
                         if (appState.isMobile) {
                            sidebar?.classList.remove('open');
                        }
                    }
                }
            });

            // --- Resize Listener ---
            window.addEventListener('resize', debounce(updateDeviceState, 250));

            // --- Keyboard Pagination Listener ---
            document.addEventListener('keydown', (e) => {
                // Only paginate if focus is not inside an input/textarea
                if (document.activeElement && ['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) {
                    return;
                }

                const paginationContainer = document.getElementById('paginationContainer');
                if (!paginationContainer || paginationContainer.style.display === 'none') return;

                if (e.key === 'ArrowLeft') {
                     e.preventDefault(); // Prevent default browser scroll
                     const btn = paginationContainer.querySelector('button:first-child:not(:disabled)');
                     if (btn) goToPage(appState.currentPage - 1);
                 } else if (e.key === 'ArrowRight') {
                     e.preventDefault(); // Prevent default browser scroll
                     const btn = paginationContainer.querySelector('button:last-child:not(:disabled)');
                     if (btn) goToPage(appState.currentPage + 1);
                 }
             });
            // --- End Other Listeners ---

            debug('Listeners setup complete');
        }


        function handleCheckboxChange(checkbox) {
              const protocol = checkbox.getAttribute('data-protocol');
              const type = checkbox.getAttribute('data-type');
              const index = checkbox.getAttribute('data-index');
              if (!protocol || !type || index === null) {
                 console.warn("Checkbox change handler missing data attributes:", checkbox);
                 return;
             }
             const key = `${protocol}-${type}-${index}`;
             const isChecked = checkbox.checked;

              appState.checkedItems[key] = isChecked;
              debug(`Checkbox changed: ${key} = ${isChecked}`);

             // Save to localStorage
             try {
                localStorage.setItem('checkedItems', JSON.stringify(appState.checkedItems));
             } catch (e) {
                console.error("Error saving checked items to localStorage:", e);
                 // Potentially notify user if storage fails (e.g., quota exceeded)
             }

             // Update visual style (strikethrough)
             const listItem = checkbox.closest('li');
             if (listItem) {
                 const textElement = listItem.querySelector('span.checkmark-animate');
                 if (textElement) {
                     textElement.classList.toggle('line-through', isChecked);
                     textElement.classList.toggle('text-gray-500', isChecked);
                 }
             } else {
                 console.warn("Could not find parent <li> for checkbox:", checkbox);
             }

             // Update the progress bar for the specific card
             updateProgressForCard(protocol);
         }


        function updateProgressForCard(protocolId) {
              // Find the protocol data in the global store
              const protocol = protocolData.find(p => p && p.id === protocolId);
             if (!protocol) {
                 // console.warn(`updateProgressForCard: Protocol data not found for ID ${protocolId}`);
                 return; // Silently return if data isn't loaded yet or ID is wrong
             }

              const cardElement = document.getElementById(protocolId);
             if (!cardElement) {
                 // console.warn(`updateProgressForCard: Card element not found for ID ${protocolId}`);
                 return; // Card might not be rendered on the current page
             }

              const totalItems = protocol.testing?.length || 0;
              const bar = cardElement.querySelector(`.progress-bar[data-protocol="${protocolId}"]`);
              const text = cardElement.querySelector('.completion-percentage');

              if (totalItems === 0) {
                 if (bar) bar.style.width = '0%';
                 if (text) text.textContent = 'N/A'; // Indicate no testing items
                 return;
             }

             // Calculate checked count based on appState.checkedItems
             let checkedCount = 0;
             if (protocol.testing) {
                protocol.testing.forEach((_, i) => {
                    if (appState.checkedItems[`${protocol.id}-testing-${i}`]) {
                        checkedCount++;
                    }
                });
            }

             const percentage = Math.round((checkedCount / totalItems) * 100);

             // Animate progress bar width
             if (bar) {
                // Get current width for animation start point
                const currentWidth = bar.style.width || '0%';
                animateElement(bar,
                    [{ width: currentWidth }, { width: `${percentage}%` }],
                    { duration: 600, easing: 'cubic-bezier(0.22, 1, 0.36, 1)', fill: 'forwards' }
                 );
             }

             // Update percentage text
             if (text) {
                text.textContent = `${percentage}%`;
            }
         }


        function updateProgress() {
              // Only update progress if data is loaded
             if (!protocolData || protocolData.length === 0) {
                 debug("Skipping progress update - no data loaded.");
                 return;
             }
             debug('Updating progress bars for visible cards');
             const visibleCards = document.querySelectorAll('#protocolCards .protocol-card');
             visibleCards.forEach(card => {
                if (card.id) {
                    updateProgressForCard(card.id); // This will check if the card/data exists
                }
            });
         }


        function animateElement(element, keyframes, options) {
              if (!element || typeof element.animate !== 'function') {
                 // Fallback: Directly apply the final style if animation is not supported or element is missing
                 if (element && keyframes.length > 0) {
                    const finalFrame = keyframes[keyframes.length - 1];
                    Object.keys(finalFrame).forEach(key => { element.style[key] = finalFrame[key]; });
                 }
                 return { finished: Promise.resolve() }; // Return a resolved promise
             }

              const effectiveOptions = { ...options };
             // Respect reduced motion preference
             if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                 effectiveOptions.duration = (options.duration || 300) * 0.1; // Significantly reduce duration
                 effectiveOptions.delay = (options.delay || 0) * 0.1; // Reduce delay too
             }

              try {
                 return element.animate(keyframes, effectiveOptions);
             } catch (e) {
                 console.error("Animation error:", e, element);
                 // Fallback on error
                 if (element && keyframes.length > 0) {
                     const finalFrame = keyframes[keyframes.length - 1];
                    Object.keys(finalFrame).forEach(key => { element.style[key] = finalFrame[key]; });
                 }
                 return { finished: Promise.resolve() };
             }
         }


        // --- MODIFIED: toggleCardExpansion (Now includes post-expansion scroll alignment) ---
        function toggleCardExpansion(card) {
            if (!card) return;
            const content = card.querySelector('.card-content');
            const icon = card.querySelector('.expand-btn i');
            const button = card.querySelector('.expand-btn');
            const id = card.id;

            if (!content || !icon || !button || !id) {
                 console.warn("Could not toggle expansion, missing elements for card:", id, card);
                 return;
            }

            const wasExpanded = card.classList.contains('expanded');
            debug(`Toggling card: ${id} (was expanded: ${wasExpanded})`);

            // Update state before animation
            if (wasExpanded) {
                appState.expandedCards.delete(id);
            } else {
                appState.expandedCards.add(id);
            }
            button.setAttribute('aria-expanded', !wasExpanded);

            // --- Collapse Animation ---
            if (wasExpanded) {
                 card.classList.remove('expanded'); // Let CSS handle max-height via class removal

                 // Animate icon rotation
                 animateElement(icon,
                    [{ transform: 'rotate(180deg)' }, { transform: 'rotate(0deg)' }],
                    { duration: 300, easing: 'ease-out', fill: 'forwards' }
                 );

                 // Fade out inner content sections slightly before collapse
                 card.querySelectorAll('.content-section').forEach((s) => animateElement(s,
                     [{ opacity: 1, transform: 'translateY(0)' }, { opacity: 0, transform: 'translateY(5px)' }],
                     { duration: 150, easing: 'ease-out', fill: 'forwards' })
                 );
                 card.querySelectorAll('.list-item-animate').forEach(item => item.style.opacity = 0);

                 // Animate the main content container's height/padding/opacity
                 const currentHeight = content.scrollHeight + 'px';
                 const anim = animateElement(content,
                     [
                         { height: currentHeight, opacity: 1, transform: 'translateY(0)', paddingBottom: '20px', paddingTop: '1rem' },
                         { height: '0px', opacity: 0, transform: 'translateY(5px)', paddingBottom: '0px', paddingTop: '0px'}
                     ],
                     { duration: 350, easing: 'cubic-bezier(0.4, 0, 0.2, 1)', fill: 'forwards' }
                 );
                 anim.finished.catch(e => console.warn("Collapse animation interrupted/cancelled", e));

            // --- Expand Animation ---
            } else {
                 card.classList.add('expanded'); // Add class to trigger CSS max-height

                 // Animate icon rotation
                 animateElement(icon,
                     [{ transform: 'rotate(0deg)' }, { transform: 'rotate(180deg)' }],
                     { duration: 350, easing: 'ease-in-out', fill: 'forwards' }
                 );

                 // Set initial styles for animation
                 content.style.height = '0px';
                 content.style.opacity = '0';
                 content.style.paddingTop = '0px';
                 content.style.paddingBottom = '0px';
                 content.style.transform = 'translateY(5px)';

                 // Animate the main content container open
                 const targetHeight = content.scrollHeight + 'px';
                 const anim = animateElement(content,
                     [
                         { height: '0px', opacity: 0, transform: 'translateY(5px)', paddingBottom: '0px', paddingTop: '0px' },
                         { height: targetHeight, opacity: 1, transform: 'translateY(0)', paddingBottom: '20px', paddingTop: '1rem' }
                     ],
                     { duration: 400, easing: 'cubic-bezier(0.2, 0, 0.1, 1)', fill: 'forwards' }
                 );

                 // After the main container finishes expanding...
                 anim.finished.then(() => {
                     // Check if the card is still meant to be expanded
                     if (!appState.expandedCards.has(id)) return;

                     // Ensure height is auto after animation
                     content.style.height = '';

                     // Animate inner sections and list items
                     card.querySelectorAll('.content-section').forEach((s, i) => animateElement(s,
                         [{ opacity: 0, transform: 'translateY(10px)' }, { opacity: 1, transform: 'translateY(0)' }],
                         { duration: 300, easing: 'ease-out', fill: 'forwards', delay: i * 50 }
                     ));
                     card.querySelectorAll('.list-item-animate').forEach((item, i) => animateElement(item,
                         [{ opacity: 0, transform: 'translateX(10px)' }, { opacity: 1, transform: 'translateX(0)' }],
                         { duration: 250, easing: 'ease-out', fill: 'forwards', delay: 100 + i * 20 }
                     ));

                     // --- <<< NEW: Final Scroll Alignment >>> ---
                     // After animations start, check scroll position
                     setTimeout(() => {
                         if (card.classList.contains('expanded')) { // Double-check it's still expanded
                             const cardRect = card.getBoundingClientRect();
                             const viewportHeight = window.innerHeight;
                             // Check if bottom is below viewport or top is above viewport
                             if (cardRect.bottom > viewportHeight || cardRect.top < 0) {
                                 debug(`Post-expansion scroll needed for ${id}`);
                                 card.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                             } else {
                                 debug(`Post-expansion scroll NOT needed for ${id}`);
                             }
                         }
                     }, 150); // Delay slightly after inner animations are triggered

                 }).catch(e => {
                     console.warn("Expand animation interrupted/cancelled", e);
                     // If cancelled, ensure final styles are applied correctly based on current state
                     if (appState.expandedCards.has(id)) {
                         // Ensure it looks expanded
                         content.style.height = ''; content.style.opacity = '1'; content.style.transform = 'translateY(0)';
                         content.style.paddingBottom = '20px'; content.style.paddingTop = '1rem';
                         card.querySelectorAll('.content-section, .list-item-animate').forEach(el => { el.style.opacity = '1'; el.style.transform = 'translate(0, 0)'; });
                     } else {
                         // Ensure it looks collapsed
                         card.classList.remove('expanded');
                         content.style.height = '0px'; content.style.opacity = '0';
                     }
                 });
             }
         }
         // --- END MODIFIED ---


        function initializeAnimations() {
              debug('Initializing Intersection Observer for animations');
              const options = {
                 root: null, // Use the viewport as the root
                 rootMargin: '0px 0px -50px 0px', // Trigger when element is 50px from bottom edge
                 threshold: 0.1 // Trigger when 10% of the element is visible
             };

              if (appState.observer) {
                 appState.observer.disconnect(); // Disconnect previous observer if resizing/reinitializing
             }

              appState.observer = new IntersectionObserver((entries, observer) => {
                 entries.forEach(entry => {
                     if (entry.isIntersecting) {
                         entry.target.classList.add('visible');
                         observer.unobserve(entry.target); // Stop observing once visible
                     }
                 });
             }, options);

              // Initial check for elements already in view
              requestAnimationFrame(handleScrollAnimations);
          }

        function handleScrollAnimations() {
             // Observe elements that need animation and are not yet visible
             const elements = document.querySelectorAll('.section-animate:not(.visible)');
             if (!appState.observer) {
                 console.warn("Observer not initialized in handleScrollAnimations");
                 return;
             }
             elements.forEach(element => {
                 appState.observer.observe(element);
             });
             // debug(`Observing ${elements.length} elements for animation.`);
         }


                // --- DYNAMIC COLOR GENERATION (REVISED: Sequential Hue + Brighter HSL) ---
        const categoryColorCache = {};
        let nextHue = Math.random() * 360; // Start at a random hue position
        const HUE_INCREMENT = 137.50776405; // Golden angle conjugate for good distribution

        function generateHslValues(str, assignedHue) {
            // Generate Saturation & Lightness variations based on the category name hash
            // This adds subtle visual difference even if hues were somehow identical (unlikely now)
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = ((hash << 5) - hash) + str.charCodeAt(i);
                hash |= 0; // Convert to 32bit integer
            }
            const absHash = Math.abs(hash);

            // --- NEW: Brighter HSL Parameters ---
            const baseSaturation = 85; // Increased base saturation
            const saturationVariation = 10; // Smaller variation range +/- 10%
            const minSaturation = 75;   // Higher minimum saturation
            const maxSaturation = 95;   // Higher maximum saturation (up to 100 is possible)

            const baseLightness = 65;   // Increased base lightness
            const lightnessVariation = 5;  // Smaller variation range +/- 5%
            const minLightness = 60;    // Higher minimum lightness
            const maxLightness = 70;    // Higher maximum lightness (avoiding too pale)

            // Calculate Saturation/Lightness with variation
            const satOffset = ((absHash >> 8) % (saturationVariation * 2 + 1)) - saturationVariation;
            const saturation = Math.min(maxSaturation, Math.max(minSaturation, baseSaturation + satOffset));

            const lightOffset = ((absHash >> 16) % (lightnessVariation * 2 + 1)) - lightnessVariation;
            const lightness = Math.min(maxLightness, Math.max(minLightness, baseLightness + lightOffset));

            // --- Generate Final Color Strings using the ASSIGNED unique hue ---
            const finalHue = assignedHue % 360; // Ensure hue is within 0-360
            const lightnessDarker = Math.max(minLightness - 10, Math.min(lightness - 15, maxLightness - 5)); // Adjust darker shade based on new lightness

            // Background Gradient
            const colorGradient = `linear-gradient(135deg, hsl(${finalHue.toFixed(0)}, ${saturation.toFixed(0)}%, ${lightness.toFixed(0)}%) 0%, hsl(${finalHue.toFixed(0)}, ${saturation.toFixed(0)}%, ${lightnessDarker.toFixed(0)}%) 100%)`;

            

            return {
                background: colorGradient,
                
            };
        }

        function getCategoryColor(category) {
            const categoryKey = (category && typeof category === 'string' && category.trim() !== '') ? category.toLowerCase() : 'uncategorized';

            // Check cache first
            if (categoryColorCache[categoryKey]) {
                return categoryColorCache[categoryKey];
            }

            // --- NEW: Assign unique hue sequentially ---
            const assignedHue = nextHue;
            nextHue += HUE_INCREMENT; // Increment for the *next* unique category

            // Generate the full color object using the assigned hue and variations from name
            const generatedColors = generateHslValues(categoryKey, assignedHue);

            debug(`Assigned unique hue ${assignedHue.toFixed(0)} for category '${categoryKey}'. Color: { background: ${generatedColors.background}, glow: ${generatedColors.glow} }`);

            // Store and return
            categoryColorCache[categoryKey] = generatedColors;
            return generatedColors;
         }
        // --- END DYNAMIC COLOR GENERATION ---


        // --- SCROLL/HIGHLIGHT/EXPAND LOGIC (Refined - Relies on global protocolData) ---
        function scrollToProtocol(id) {
             if (!protocolData || protocolData.length === 0) {
                 debug("Cannot scroll: Protocol data not loaded.");
                 return;
             }
             const protocol = protocolData.find(p => p && p.id === id);
             if (!protocol) {
                 debug(`Protocol not found in loaded data: ${id}`);
                 return;
             }

             // Check if the protocol's category matches the current filter
             const needsFilterChange = appState.currentFilter !== 'all' && protocol.category !== appState.currentFilter;

             if (needsFilterChange) {
                 debug(`Switching filter to '${protocol.category}' for scroll target '${id}'`);
                 filterByCategory(protocol.category); // This will trigger re-render
                 // Need to wait for the re-render to complete before finding and scrolling
                 setTimeout(() => findAndScrollToProtocol(id), 400); // Delay allows render + pagination update
             } else {
                 // Already on correct filter (or 'all'), proceed to find page and scroll
                 findAndScrollToProtocol(id);
             }
         }

        function findAndScrollToProtocol(id) {
             // Get the currently filtered list again (important after potential filter change)
             const filtered = getFilteredProtocols();
             const index = filtered.findIndex(p => p && p.id === id);

             if (index === -1) {
                 debug(`Protocol '${id}' not found in currently filtered list.`);
                 // Maybe show a message? Or just log it.
                 return;
             }

             const targetPage = Math.floor(index / appState.itemsPerPage) + 1;

             if (targetPage !== appState.currentPage) {
                 debug(`Navigating to page ${targetPage} to show '${id}'`);
                 // Use goToPage which handles state update and rendering
                 goToPage(targetPage);
                 // Wait for the render triggered by goToPage to complete
                 setTimeout(() => scrollAndHighlight(id), 400); // Delay might need adjustment based on render speed
             } else {
                 // Already on the correct page, just scroll and highlight
                 scrollAndHighlight(id);
             }
         }

        // --- MODIFIED: scrollAndHighlight (Now triggers expansion which handles its own final scroll) ---
        function scrollAndHighlight(id) {
             // Use rAF to ensure layout is stable after potential render/page change
             requestAnimationFrame(() => {
                 const element = document.getElementById(id);
                 if (!element) {
                     // Element might not be rendered *immediately* after page change, try again shortly
                     setTimeout(() => {
                         const elementRetry = document.getElementById(id);
                         if (!elementRetry) {
                             debug(`Element #${id} not found for highlight after retry.`);
                             return;
                         }
                         performScrollAndHighlight(elementRetry);
                     }, 150); // Short delay for retry
                     return;
                 }
                 performScrollAndHighlight(element);
             });
        }

        // --- MODIFIED: performScrollAndHighlight (Applies category glow, triggers expansion) ---
         function performScrollAndHighlight(element) {
             const id = element.id;
             debug(`Performing Scroll & Highlight for: ${id}`);

             const needsExpansion = !element.classList.contains('expanded');
             const highlightDelay = 50; // Delay before applying highlight after initial scroll

             // --- Step 1: Initial Scroll into view (nearest edge) ---
             // This happens first to get the card roughly in view.
             element.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
             debug(`Performed initial 'smooth' scroll to nearest for ${id}`);

             // --- Step 2: Expand if needed (after a short delay allowing scroll to start) ---
             // The toggleCardExpansion function itself now handles the final scroll alignment *after* it finishes expanding.
             setTimeout(() => {
                 if (!document.getElementById(id)) { debug(`Element ${id} disappeared after initial scroll.`); return; }

                 if (needsExpansion) {
                     debug(`Triggering expansion for ${id} (final scroll handled by toggleCardExpansion)`);
                     toggleCardExpansion(element); // This starts its own animation AND post-animation scroll check
                 }

                 // --- Step 3: Highlight (slight delay after scroll/start of expansion) ---
                 setTimeout(() => {
                     if (!document.getElementById(id)) { debug(`Element ${id} disappeared before highlight.`); return; }

                     debug(`Applying highlight for ${id}`);

                     // --- <<< NEW: Get Category Glow Color >>> ---
                     const protocol = protocolData.find(p => p && p.id === id);
                     const categoryColor = getCategoryColor(protocol?.category);
                     const glowColorValue = categoryColor?.glow || 'rgba(139, 92, 246, 0.5)'; // Fallback glow
                     // --- <<< END NEW >>> ---

                     const originalShadow = getComputedStyle(element).boxShadow;
                     element.classList.add('highlighting'); // Add class to manage transition override

                     // Apply highlight glow using the category color. Combine with original shadow.
                     element.style.boxShadow = `0 0 25px 5px ${glowColorValue}, ${originalShadow || '0 8px 32px rgba(0, 0, 0, 0.2)'}`; // Add glow

                     // Remove highlight after duration
                     setTimeout(() => {
                          if (document.getElementById(id)) { // Check again if element still exists
                             element.style.boxShadow = originalShadow || ''; // Restore original shadow
                             // Remove the class slightly after restoring shadow to allow transition out
                             setTimeout(() => {
                                 if (document.getElementById(id)) {
                                     element.classList.remove('highlighting');
                                     debug(`Removed highlight for ${id}`);
                                 }
                             }, 300); // Duration of the highlight transition defined in CSS
                         }
                     }, 1500); // Duration the highlight stays visible

                 }, highlightDelay); // Delay relative to starting expansion/scroll

             }, 100); // Delay after initial scroll before starting expansion/highlight logic
         }
        // --- END SCROLL/HIGHLIGHT/EXPAND LOGIC ---

    </script>
</body>
</html>
